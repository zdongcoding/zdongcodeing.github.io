<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zdongの博客</title>
  
  <subtitle>热爱  coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zoudongq123.cn/"/>
  <updated>2019-03-16T09:32:02.156Z</updated>
  <id>http://blog.zoudongq123.cn/</id>
  
  <author>
    <name>zoudong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeakCanary源码分析</title>
    <link href="http://blog.zoudongq123.cn/2018/11/28/LeakCanary%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zoudongq123.cn/2018/11/28/LeakCanary源码分析/</id>
    <published>2018-11-28T09:26:41.000Z</published>
    <updated>2019-03-16T09:32:02.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeakCanary源码分析"><a href="#LeakCanary源码分析" class="headerlink" title="LeakCanary源码分析"></a>LeakCanary源码分析</h1><blockquote><p>基于版本  1.6.3</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:1.6.3'</span></span><br><span class="line">  releaseImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'</span></span><br><span class="line">  <span class="comment">// Optional, if you use support library fragments:</span></span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Application 注入 初始化代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="comment">//LeakCanary.isInAnalyzerProcess(this)会调用 sInServiceProcess(context, HeapAnalyzerService.class)来判断是否跟HeapAnalyzerService在同一个进程中。</span></span><br><span class="line">    <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">      <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Normal app init code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>aar 自带  以下不需要开发者编写<br>HeapAnalyzerService是一个IntentServcie，主要用来分析生成的hprof文件。我们看下HeapAnalyzerService的清单配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".internal.HeapAnalyzerService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">":leakcanary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看到，这个服务运行在单独的“:leakcanary”进程中。如果你浏览下LeakCanary的其他android组件（DisplayLeakService，DisplayLeakActivity等）清单配置，会发现它们都是运行在这个进程中的。为什么HeapAnalyzerService要单独放在这个进程？因为内存泄露时，生成的hprof文件很大，解析的时候会耗费大量内存，如果放在app主进程中，可能会导致OOM。</p><p>另外，我们也注意到<code>android:enabled=&quot;false&quot;</code>这个属性设置，那说明默认情况下，HeapAnalyzerService这个service是不可用的，<strong>那它什么时候打开呢？</strong> 带着这个疑问我们接着往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.squareup.leakcanary.internal.LeakCanaryInternals</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInServiceProcess</span><span class="params">(Context context, Class&lt;? extends Service&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    PackageInfo packageInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      CanaryLog.d(e, <span class="string">"Could not get package info for %s"</span>, context.getPackageName());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String mainProcess = packageInfo.applicationInfo.processName;</span><br><span class="line"></span><br><span class="line">    ComponentName component = <span class="keyword">new</span> ComponentName(context, serviceClass);</span><br><span class="line">    ServiceInfo serviceInfo;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      serviceInfo = packageManager.getServiceInfo(component, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException ignored) &#123;</span><br><span class="line">      <span class="comment">// Service is disabled.</span></span><br><span class="line">      <span class="comment">/****标记1*******.首次运行的时候，HeapAnalyzerService组件没有打开，所以到这里就返回了***/</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HeapAnalyzerService激活后才会有下边的代码</span></span><br><span class="line">    <span class="keyword">if</span> (serviceInfo.processName.equals(mainProcess)) &#123;<span class="comment">/****标记2*******/</span></span><br><span class="line">      CanaryLog.d(<span class="string">"Did not expect service %s to run in main process %s"</span>, serviceClass, mainProcess);</span><br><span class="line">      <span class="comment">// Technically we are in the service process, but we're not in the service dedicated process.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> myPid = android.os.Process.myPid();</span><br><span class="line">    ActivityManager activityManager =</span><br><span class="line">        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.RunningAppProcessInfo myProcess = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; runningProcesses;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runningProcesses = activityManager.getRunningAppProcesses();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException exception) &#123;</span><br><span class="line">      <span class="comment">// https://github.com/square/leakcanary/issues/948</span></span><br><span class="line">      CanaryLog.d(<span class="string">"Could not get running app processes %d"</span>, exception);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runningProcesses != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo process : runningProcesses) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.pid == myPid) &#123;</span><br><span class="line">          myProcess = process;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (myProcess == <span class="keyword">null</span>) &#123;</span><br><span class="line">      CanaryLog.d(<span class="string">"Could not find running process for %d"</span>, myPid);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myProcess.processName.equals(serviceInfo.processName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上边我们说过，HeapAnalyzerService组件默认是关闭的，所以一次执行的时候，到代码中1标识的位置就结束了。第二次执行的时候，才会往下走。此外，在2标记的的位置,如果你把HeapAnalyzerService的进程设置为跟主进程一样，LeakCanary依然可以工作，但要小心OOM。再往下就是判断HeapAnalyzerService服务进程是否跟主进程一样。</p><h3 id="查看内存泄漏"><a href="#查看内存泄漏" class="headerlink" title="查看内存泄漏"></a>查看内存泄漏</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="如何判断内存泄漏"><a href="#如何判断内存泄漏" class="headerlink" title="如何判断内存泄漏"></a>如何判断内存泄漏</h3><blockquote><p>弱引用探测内存泄露<br>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)<br>referent被gc回收时，会将包裹它的弱引用注册到ReferenceQueue中，在gc后判断ReferenceQueue有没有referent包裹的WeakReference，就可以判断是否被gc正常回收。</p></blockquote><h3 id="LeakCanary-install"><a href="#LeakCanary-install" class="headerlink" title="LeakCanary.install"></a><code>LeakCanary.install</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> <span class="function">RefWatcher <span class="title">install</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">        .buildAndInstall();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@NonNull</span> <span class="function">AndroidRefWatcherBuilder <span class="title">refWatcher</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AndroidRefWatcherBuilder(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intall方法中，生成了AndroidRefWatcherBuilder对象，设置了一些参数，并最终调用了buildAndInstall()。</p><h3 id="AndroidRefWatcherBuilder"><a href="#AndroidRefWatcherBuilder" class="headerlink" title="AndroidRefWatcherBuilder"></a><code>AndroidRefWatcherBuilder</code></h3><table><thead><tr><th>参数类型</th><th>默认实现</th><th>android平台实现类</th><th>含义</th></tr></thead><tbody><tr><td>HeapDump.Listener</td><td>HeapDump.Listener.NONE</td><td>ServiceHeapDumpListener</td><td>执行分析HeapDump，在android中是在启动DisplayLeakService在一个新的的进程中，执行解析dump</td></tr><tr><td>DebuggerControl</td><td>DebuggerControl.NONE</td><td>AndroidDebuggerControl</td><td>判断进程是否处于debug状态</td></tr><tr><td>HeapDumper</td><td>HeapDumper.NONE</td><td>AndroidHeapDumper</td><td>dump heap到文件中</td></tr><tr><td>GcTrigger</td><td>GcTrigger.DEFAULT</td><td>GcTrigger.DEFAULT</td><td>主动调用GC</td></tr><tr><td>WatchExecutor</td><td>WatchExecutor.NONE</td><td>AndroidWatchExecutor</td><td>延迟调用GC的执行器；在android平台是内部有一个HandThread，通过 handler来做延迟操作</td></tr><tr><td>HeapDump.Builder</td><td>HeapDump.Builder</td><td>HeapDump.Builder</td><td>主要是构造执行dump时的一些参数</td></tr></tbody></table><p>注意两点：</p><ul><li>AndroidRefWatcherBuilder与RefWatcherBuilder使用了builder模式，可以看下是怎么用泛型实现Builder模式的继承结构的。</li><li>参数里边的默认实现，都是在接口定义中使用匿名内部类定义了一个默认的的实现，这种写法可以参考，比如DebuggerControl的定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DebuggerControl</span> </span>&#123;</span><br><span class="line">  DebuggerControl NONE = <span class="keyword">new</span> DebuggerControl() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebuggerAttached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebuggerAttached</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上边说的HeapDump.Builder（Builder模式），最终会构造一个HeapDump对象，看下他有哪些参数：</p><table><thead><tr><th>参数名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>heapDumpFile</td><td>File</td><td>hprof文件路径</td></tr><tr><td>referenceKey</td><td>String</td><td>是一个UUID，用来唯一标识一个要监测的对象的</td></tr><tr><td>referenceName</td><td>String</td><td>用户给监控对象自己定义的名字</td></tr><tr><td>excludedRefs</td><td>ExcludedRefs</td><td>要排除的类集合；因为有些内存泄露，不</td><td>是我们的程序导致的，而是系统的bug，这些bug我们无能为力，所以做了这样一个列</td><td>表，把这些泄露问题排除掉，不会展示给我们</td></tr><tr><td>watchDurationMs</td><td>long</td><td>执行RefWatcher.watch(）之后，到最终监测到内</td><td>存泄露花费的时间</td></tr><tr><td>gcDurationMs</td><td>long</td><td>手动执行gc花费的时间</td></tr><tr><td>heapDumpDurationMs</td><td>long</td><td>记录dump内存花费的时间</td></tr><tr><td>computeRetainedHeapSize</td><td>boolean</td><td>是否计算持有的堆的大小</td></tr><tr><td>reachabilityInspectorClasses</td><td>List<class<? extends="" reachability.inspector="">&gt;</class<?></td><td>？</td></tr></tbody></table><ul><li>AndroidRefWatcherBuilder#listenerServiceClass()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sets a custom &#123;<span class="doctag">@link</span> AbstractAnalysisResultService&#125; to listen to analysis results. This</span></span><br><span class="line"><span class="comment">  * overrides any call to &#123;<span class="doctag">@link</span> #heapDumpListener(HeapDump.Listener)&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">AndroidRefWatcherBuilder <span class="title">listenerServiceClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class="line">    <span class="keyword">return</span> heapDumpListener(<span class="keyword">new</span> ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>ServiceHeapDumpListener</code>：先简单说下这个listsener的作用，当监测到内存泄露时，就会hprof文件回调给这个listener，在回调中它会启启动独立的进程，解析这这个文件，并将解析结果传给<code>AbstractAnalysisResultService</code>的实现类，也即install方法中传入的<code>DisplayLeakService</code>，<code>DisplayLeakService</code>会弹出系统通知提示发生了内存泄露，这个listener将整个流程串了起来。 <code>DisplayLeakService</code> 最后会讲到!<br>再往下看最后调用的<code>AndroidRefWatcherBuilder.buildAndInstall()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@link</span> RefWatcher&#125; instance and makes it available through &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * LeakCanary#installedRefWatcher()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also starts watching activity references if &#123;<span class="doctag">@link</span> #watchActivities(boolean)&#125; was set to true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if called more than once per Android process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LeakCanaryInternals.installedRefWatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"buildAndInstall() should only be called once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  RefWatcher refWatcher = build();</span><br><span class="line">  <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class="line">      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">      ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">      FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">  <span class="keyword">return</span> refWatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build()是用之前传的参数构造了一个RefWatcher对象返回给我们，检测对象内存泄露的逻辑都是这个类处理的。<br>接下来异步激活组件DisplayLeakActivity，它是用来展示泄露列表信息的，激活组件调用的是 <strong>packageManager.setComponentEnabledSetting()</strong> 这个api，它可以实现一些特殊的功能，比如如果有系统权限，可以屏蔽应用开机监听广播，有兴趣的可以google一下。因为这个方法可能会阻塞IPC通信，所以放在了异步里边执行。</p><ul><li>LeakCanaryInternals.setEnabledAsync()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEnabledAsync</span><span class="params">(Context context, <span class="keyword">final</span> Class&lt;?&gt; componentClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context appContext = context.getApplicationContext();</span><br><span class="line">    AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setEnabledBlocking(appContext, componentClass, enabled);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEnabledBlocking</span><span class="params">(Context appContext, Class&lt;?&gt; componentClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    ComponentName component = <span class="keyword">new</span> ComponentName(appContext, componentClass);</span><br><span class="line">    PackageManager packageManager = appContext.getPackageManager();</span><br><span class="line">    <span class="keyword">int</span> newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;</span><br><span class="line">    <span class="comment">// Blocks on IPC.</span></span><br><span class="line">    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>激活之后，我们桌面上会多一个图标，为什么会多一个图标？谜底就在他的清单配置中的intent-filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">激活之后，我们桌面上会多一个图标，为什么会多一个图标？谜底就在他的清单配置中的intent-filter</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/leak_canary_LeakCanary.Base"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">".internal.DisplayLeakActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">":leakcanary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">....</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那具体什么时候触发检测的呢？这就是ActivityRefWatcher和FragmentRefWatcher要做的事儿。对于Activity和Fragment来说，当它的onDestory()被回调之后，就应该被系统回调掉。</p><h3 id="ActivityRefWatcher"><a href="#ActivityRefWatcher" class="headerlink" title="ActivityRefWatcher"></a><code>ActivityRefWatcher</code></h3><ul><li>com.squareup.leakcanary.ActivityRefWatcher#install()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">    Application application = (Application) context.getApplicationContext();</span><br><span class="line">    ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line"></span><br><span class="line">    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">      <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">          refWatcher.watch(activity);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里我们就能证实了当<code>Acitivity.onDestroy()</code> 监听内存泄露 <code>refWatcher.watch(activity);</code></p><h3 id="FragmentRefWatcher"><a href="#FragmentRefWatcher" class="headerlink" title="FragmentRefWatcher"></a><code>FragmentRefWatcher</code></h3><ul><li>com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context, RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">  List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">    fragmentRefWatchers.add(<span class="keyword">new</span> AndroidOFragmentRefWatcher(refWatcher));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);</span><br><span class="line">    Constructor&lt;?&gt; constructor =</span><br><span class="line">        fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);</span><br><span class="line">    FragmentRefWatcher supportFragmentRefWatcher =</span><br><span class="line">        (FragmentRefWatcher) constructor.newInstance(refWatcher);</span><br><span class="line">    fragmentRefWatchers.add(supportFragmentRefWatcher);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fragmentRefWatchers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Helper helper = <span class="keyword">new</span> Helper(fragmentRefWatchers);</span><br><span class="line">  Application application = (Application) context.getApplicationContext();</span><br><span class="line">  application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (FragmentRefWatcher watcher : fragmentRefWatchers) &#123;</span><br><span class="line">          watcher.watchFragments(activity);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Fragment的onDestory() <code>监听的是Acitivity#onDestory()</code> 监听要麻烦一些，我们知道以前不管是原生和support库中的Fragment是没有统一的系统回调的，后来在Support库中和android O以上的版本增加了对fragment的生命周期回调<code>fragmentManager.registerFragmentLifecycleCallbacks()</code>。<br>我们只看下是如何对Support库中的fragment处理的。</p><ul><li>com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresApi</span>(Build.VERSION_CODES.O) <span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidOFragmentRefWatcher</span> <span class="keyword">implements</span> <span class="title">FragmentRefWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">  AndroidOFragmentRefWatcher(RefWatcher refWatcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.refWatcher = refWatcher;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =</span><br><span class="line">      <span class="keyword">new</span> FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(FragmentManager fm, Fragment fragment)</span> </span>&#123;</span><br><span class="line">          View view = fragment.getView();</span><br><span class="line">          <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            refWatcher.watch(view);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentDestroyed</span><span class="params">(FragmentManager fm, Fragment fragment)</span> </span>&#123;</span><br><span class="line">          refWatcher.watch(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchFragments</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    FragmentManager fragmentManager = activity.getFragmentManager();</span><br><span class="line">    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>com.squareup.leakcanary.internal.SupportFragmentRefWatcher</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupportFragmentRefWatcher</span> <span class="keyword">implements</span> <span class="title">FragmentRefWatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">  SupportFragmentRefWatcher(RefWatcher refWatcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.refWatcher = refWatcher;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =</span><br><span class="line">      <span class="keyword">new</span> FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(FragmentManager fm, Fragment fragment)</span> </span>&#123;</span><br><span class="line">          View view = fragment.getView();</span><br><span class="line">          <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            refWatcher.watch(view);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFragmentDestroyed</span><span class="params">(FragmentManager fm, Fragment fragment)</span> </span>&#123;</span><br><span class="line">          refWatcher.watch(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchFragments</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      FragmentManager supportFragmentManager =</span><br><span class="line">          ((FragmentActivity) activity).getSupportFragmentManager();</span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于Fragment来对，LeakCanary除了监控fragment又没有回收外，还会监测Fragment的view有没有被及时回收。AndroidOFragmentRefWatcher的代码跟上边的类似。<br>在android O及以上版本是通过<code>AndroidOFragmentRefWatcher</code>来处理，如果用的是最新的support库，是通过<code>SupportFragmentRefWatcher</code>来处理,他们都继承在FragmentRefWatcher。<code>AndroidOFragmentRefWatcher</code>和 <code>SupportFragmentRefWatcher</code> 代码基本一样为了适配API !</p><h3 id="RefWatcher-watch"><a href="#RefWatcher-watch" class="headerlink" title="RefWatcher.watch()"></a><code>RefWatcher.watch()</code></h3><blockquote><p>从上可以看到，不管是<code>Fragment</code>,<code>Activity</code>还是<code>View</code>最终都调用了同一个<code>RefWatcher.watch()</code>方法，</p></blockquote><p>以Activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watches the provided references and checks if it can be GCed. This method is non blocking,</span></span><br><span class="line"><span class="comment"> * the check is done on the &#123;<span class="doctag">@link</span> WatchExecutor&#125; this &#123;<span class="doctag">@link</span> RefWatcher&#125; has been constructed</span></span><br><span class="line"><span class="comment"> * with.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> referenceName An logical identifier for the watched object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</span><br><span class="line">  checkNotNull(referenceName, <span class="string">"referenceName"</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// com.squareup.leakcanary.AndroidWatchExecutor   watchExecutor</span></span><br><span class="line">    watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> Retryable.<span class="function">Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>KeyedWeakReference</code> 继承自WeakReference，增加的key和referenceName，这个key会同时放入Set集合中，方便gc回收对象后，做对比。<br><code>watchExecutor</code> 在Android中实现是<code>AndroidWatchExecutor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.squareup.leakcanary.AndroidWatchExecutor#execute</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(@NonNull Retryable retryable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</span><br><span class="line">    waitForIdle(retryable, <span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    postWaitForIdle(retryable, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>waitForIdle</code> 和  <code>postWaitForIdle</code> 最终还是调用 <code>waitForIdle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This needs to be called from the main thread.</span></span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToBackgroundWithDelay</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> exponentialBackoffFactor = (<span class="keyword">long</span>) Math.min(Math.pow(<span class="number">2</span>, failedAttempts), maxBackoffFactor);</span><br><span class="line">    <span class="keyword">long</span> delayMillis = initialDelayMillis * exponentialBackoffFactor;</span><br><span class="line">    <span class="comment">//  HandlerThread</span></span><br><span class="line">    backgroundHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Retryable.Result result = retryable.run();</span><br><span class="line">        <span class="keyword">if</span> (result == RETRY) &#123;</span><br><span class="line">          postWaitForIdle(retryable, failedAttempts + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类会在主UI线程空闲的时候，向内部的HandlerThread发送一个消息，执行execute方法传给他的Retryable对象，<br>调用<code>retryable.run()</code>，如果返回RETRY会继续等待下一个主UI线程空闲回调，直至返回为Done，每次重试都会增大间隔时间。</p><p><strong>注意：是通过 Looper.myQueue().addIdleHandler（）来监听系统主线程空闲的</strong></p><p>到这里我们就应该知道<code>ensureGone</code>最开始这个方法被执行的 <code>HandlerThread</code>线程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ReferenceEquality"</span>) <span class="comment">// Explicitly checking for named null.</span></span><br><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一次调用如果系统GC 减少引用</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="comment">// The debugger can create false leaks.</span></span><br><span class="line">    <span class="keyword">return</span> RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  <span class="comment">//第二次调用 主动GC 在判断引用 减少误报</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">  <span class="comment">//到这里就有可能出现内存泄露了</span></span><br><span class="line">    <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">  <span class="comment">// 关键时刻  heapDumper 实现是 com.squareup.leakcanary.AndroidHeapDumper</span></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    <span class="comment">//生成  dump  文件</span></span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="comment">// Could not dump the heap.</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">    <span class="comment">// 将dump文件构造成HeapDump 对象</span></span><br><span class="line">    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//HeapDump 对象 heapdumpListener对应的是ServiceHeapDumpListener的analyze（）</span></span><br><span class="line">    heapdumpListener.analyze(heapDump);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeWeaklyReachableReferences</code>调用了两次，第一次调用后，如果系统gc正常回收，retainedKeys就不会再包含<code>KeyedWeakReference</code> 的key；如果没有回收，会手动调用gc，再判断，减少误报；如果两次gc后，对象仍然没有被回收，可能就是真的内存泄露了。再调用heapDumper.dumpHeap()得到内存数据。heapDumper对应的是<code>AndroidHeapDumper</code>，<code>LeakDirectoryProvider</code> 指定了dumperHeap()的文件夹路径。<br><code>heapDumper.dumpHeap();</code>生成文件后，并且生成HeapDump 对象,HeapDump 对象 heapdumpListener对应的是<code>ServiceHeapDumpListener</code>的analyze（）</p><ul><li>com.squareup.leakcanary.AndroidHeapDumper</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="meta">@NonNull</span> <span class="function">HeapDumper <span class="title">defaultHeapDumper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LeakDirectoryProvider leakDirectoryProvider =</span><br><span class="line">        LeakCanaryInternals.getLeakDirectoryProvider(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AndroidHeapDumper(context, leakDirectoryProvider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">dumpHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FutureResult&lt;Toast&gt; waitingForToast = <span class="keyword">new</span> FutureResult&lt;&gt;();</span><br><span class="line">    showToast(waitingForToast);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!waitingForToast.wait(<span class="number">5</span>, SECONDS)) &#123;</span><br><span class="line">      CanaryLog.d(<span class="string">"Did not dump heap, too much time waiting for Toast."</span>);</span><br><span class="line">      <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(context)</span><br><span class="line">        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));</span><br><span class="line">    Notification notification = LeakCanaryInternals.buildNotification(context, builder);</span><br><span class="line">    NotificationManager notificationManager =</span><br><span class="line">        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    <span class="keyword">int</span> notificationId = (<span class="keyword">int</span>) SystemClock.uptimeMillis();</span><br><span class="line">    notificationManager.notify(notificationId, notification);</span><br><span class="line"></span><br><span class="line">    Toast toast = waitingForToast.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</span><br><span class="line">      cancelToast(toast);</span><br><span class="line">      notificationManager.cancel(notificationId);</span><br><span class="line">      <span class="keyword">return</span> heapDumpFile;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      CanaryLog.d(e, <span class="string">"Could not dump heap"</span>);</span><br><span class="line">      <span class="comment">// Abort heap dump</span></span><br><span class="line">      <span class="keyword">return</span> RETRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>dumpHeap会弹出一个通知，显示Dumping，并调用<code>Debug.dumpHprofData(heapDumpFile.getAbsolutePath())</code>来保存内存，如果异常dumpHprofData异常会重试。</p><p>如果dump成功heapDumper.dumpHeap()，会构造HeapDump 对象，<code>ensureGone()   --&gt;  heapdumpListener.analyze(heapDump);</code> 并传递给<code>heapdumpListener</code>。前边我们说过<code>heapdumpListener</code>对应的是<code>ServiceHeapDumpListener</code>的analyze（）</p><blockquote><p> heapdumpListener 是在 <code>com.squareup.leakcanary.LeakCanary#install()</code>中调用 <code>listenerServiceClass</code>,<code>heapDumpListener()</code> </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.squareup.leakcanary.ServiceHeapDumpListener#analyze</span></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(@NonNull HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">    checkNotNull(heapDump, <span class="string">"heapDump"</span>);</span><br><span class="line">    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// com.squareup.leakcanary.internal.HeapAnalyzerService#runAnalysis</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAnalysis</span><span class="params">(Context context, HeapDump heapDump,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    setEnabledBlocking(context, HeapAnalyzerService.class, <span class="keyword">true</span>);</span><br><span class="line">    setEnabledBlocking(context, listenerServiceClass, <span class="keyword">true</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, HeapAnalyzerService.class);</span><br><span class="line">    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</span><br><span class="line">    intent.putExtra(HEAPDUMP_EXTRA, heapDump);</span><br><span class="line">    ContextCompat.startForegroundService(context, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[注意]</strong>:<code>DisplayLeakActivity</code>,已经调用pm.setComponentEnabledSetting()方法激活组件了，但listenerServiceClass对应的<code>DisplayLeakService</code>和<code>HeapAnalyzerService</code>还没有激活，所以在启动<code>HeapAnalyzerService</code>时，要先把这两个组件激活。<br><code>HeapAnalyzerService</code>是一个前台IntentService，最终回调到他的<code>onHandleIntentInForeground</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntentInForeground</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">      CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">    HeapAnalyzer heapAnalyzer =</span><br><span class="line">        <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs, <span class="keyword">this</span>, heapDump.reachabilityInspectorClasses);</span><br><span class="line">    <span class="comment">//生成泄露对象引用链</span></span><br><span class="line">    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">        heapDump.computeRetainedHeapSize);</span><br><span class="line">      <span class="comment">// listenerClassName=DisplayLeakService</span></span><br><span class="line">    AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onHandleIntentInForeground中根据Intent的参数，构造了heapAnalyzer ，调用<code>heapAnalyzer.checkForLeak()</code>得到泄露对象的引用链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendResultToListener</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull String listenerServiceClassName,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull HeapDump heapDump,</span></span></span><br><span class="line"><span class="function"><span class="params">      @NonNull AnalysisResult result)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; listenerServiceClass;</span><br><span class="line">    <span class="comment">// DisplayLeakService</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      listenerServiceClass = Class.forName(listenerServiceClassName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, listenerServiceClass);</span><br><span class="line"></span><br><span class="line">    File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);</span><br><span class="line">    <span class="keyword">if</span> (analyzedHeapFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">      intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">    ContextCompat.startForegroundService(context, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的结果通过AnalyzedHeap.save(heapDump, result)保存到了一个文件冲，并返回给listenerServiceClassName代表的Sersvice，即DisplayLeakService，这个服务也是一个前台IntentService，最终回调到DisplayLeakService的onHeapAnalyzed方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayLeakService</span> <span class="keyword">extends</span> <span class="title">AbstractAnalysisResultService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">onHeapAnalyzed</span><span class="params">(@NonNull AnalyzedHeap analyzedHeap)</span> </span>&#123;</span><br><span class="line">    HeapDump heapDump = analyzedHeap.heapDump;</span><br><span class="line">    AnalysisResult result = analyzedHeap.result;</span><br><span class="line"></span><br><span class="line">    String leakInfo = leakInfo(<span class="keyword">this</span>, heapDump, result, <span class="keyword">true</span>);</span><br><span class="line">    CanaryLog.d(<span class="string">"%s"</span>, leakInfo);</span><br><span class="line"></span><br><span class="line">    heapDump = renameHeapdump(heapDump);</span><br><span class="line">    <span class="keyword">boolean</span> resultSaved = saveResult(heapDump, result);</span><br><span class="line"></span><br><span class="line">    String contentTitle;</span><br><span class="line">    <span class="keyword">if</span> (resultSaved) &#123;</span><br><span class="line">      PendingIntent pendingIntent =</span><br><span class="line">          DisplayLeakActivity.createPendingIntent(<span class="keyword">this</span>, heapDump.referenceKey);</span><br><span class="line">      <span class="keyword">if</span> (result.failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        contentTitle = getString(R.string.leak_canary_analysis_failed);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String className = classSimpleName(result.className);</span><br><span class="line">        <span class="keyword">if</span> (result.leakFound) &#123;</span><br><span class="line">          <span class="keyword">if</span> (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.excludedLeak) &#123;</span><br><span class="line">              contentTitle = getString(R.string.leak_canary_leak_excluded, className);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              contentTitle = getString(R.string.leak_canary_class_has_leaked, className);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String size = formatShortFileSize(<span class="keyword">this</span>, result.retainedHeapSize);</span><br><span class="line">            <span class="keyword">if</span> (result.excludedLeak) &#123;</span><br><span class="line">              contentTitle =</span><br><span class="line">                  getString(R.string.leak_canary_leak_excluded_retaining, className, size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              contentTitle =</span><br><span class="line">                  getString(R.string.leak_canary_class_has_leaked_retaining, className, size);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          contentTitle = getString(R.string.leak_canary_class_no_leak, className);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String contentText = getString(R.string.leak_canary_notification_message);</span><br><span class="line">      showNotification(pendingIntent, contentTitle, contentText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterDefaultHandling(heapDump, result, leakInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将泄露结果在系统通知栏上显示。</p><p>以上，LeakCanary从注册Activity和Fragment的生命周期回调，到<code>onDestory</code>中开始<code>RefWatcher.watch()</code>,然后dumpHeap，再分析内存泄露引用链，最后将结果展示到系统通知栏的整个过程就基本分析完毕了。</p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hsp3z74ej219m0kfq5s.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结下看源码过程中学到的知识点：</p><ul><li>内存泄露如何判断（WeakReference）</li><li>Debug.dumpHprofData（）获取内存数据，Debug.isDebuggerConnected()判断是否debug</li><li>setComponentEnabledSetting()动态开关组件</li><li>Looper.myQueue().addIdleHandler（）注册UI线程空闲回调</li></ul><p><a href="https://www.jianshu.com/p/b857736d1461" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeakCanary源码分析&quot;&gt;&lt;a href=&quot;#LeakCanary源码分析&quot; class=&quot;headerlink&quot; title=&quot;LeakCanary源码分析&quot;&gt;&lt;/a&gt;LeakCanary源码分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于版本  1.6
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之Lifecycle的源码分析</title>
    <link href="http://blog.zoudongq123.cn/2018/10/16/Jetpack%E4%B9%8BLifecycle%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zoudongq123.cn/2018/10/16/Jetpack之Lifecycle的源码分析/</id>
    <published>2018-10-16T05:29:27.000Z</published>
    <updated>2019-03-16T09:28:36.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Jetpack之Lifecycle的源码分析"><a href="#Android-Jetpack之Lifecycle的源码分析" class="headerlink" title="Android Jetpack之Lifecycle的源码分析"></a>Android Jetpack之Lifecycle的源码分析</h1><p>Lifecycle组件中的类结构，<code>LifecycleOwner</code>表示拥有生命周期功能。<br>Lifecycle定义了Android中的生命周期的接口。而<code>LifecycleObserver</code>是生命周期的监听的接口。Lifecycle可以注册和反注册<code>LifecycleObserver</code>，二者为观察者模式。</p><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jm1iyj40j23l41boaoo.jpg" alt=""></p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LifecycleOwner</code>只有一个简单的接口，获取<code>Lifecycle</code>。而support现在的库中的<code>Fragment</code>和<code>AppCompatActivity</code>均实现了此接口。</p><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jm1r5f1lj20rs0s6mxo.jpg" alt=""></p><p>现在的support库中的Fragment实现了LifecycleOwner，我们来观摩一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fragment</code>直接返回变量<code>mLifecycleRegistry</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>变量是LifecycleRegistry的对象。</p><p><code>Fragment</code>实现了<code>LifecycleOwner</code>，并返回了<code>LifecycleRegistry</code>类的对象。<br>那<code>mLifecycleRegistry</code>怎么知道生命周期变化的呢？</p><blockquote><p>在<code>performCreate</code>方法中，调用支持<code>onCreate</code>方法并使用<code>mLifecycleRegistry</code>来处理<code>Lifecycle.Event.ON_CREATE</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ······</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">    ······</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的：</p><ul><li><code>performStart</code>调用<code>onStart</code>方法并使用<code>mLifecycleRegistry</code>处理<code>Lifecycle.Event.ON_START</code></li><li><code>performResume</code>调用<code>onResume</code>方法并使用<code>mLifecycleRegistry</code>处理<code>Lifecycle.Event.ON_RESUME</code></li><li><code>performStop</code>调用<code>onStop</code>方法并使用<code>mLifecycleRegistry</code>处理<code>Lifecycle.Event.ON_STOP</code></li><li><code>performDestroy</code>调用<code>onDestroy</code>并使用<code>mLifecycleRegistry</code>处理<code>Lifecycle.Event.ON_DESTROY</code></li></ul><p>调用生命周期的相关的方法的同时，也使用<code>mLifecycleRegistry</code>处理<code>Lifecycle.Event</code>中的相应事件。</p><p><code>mLifecycleRegistry</code>通过此种方式来监听生命周期的变更的。（至于什么时候执行performXX方法可以自行分析）。</p><h3 id="AppCompatActivity"><a href="#AppCompatActivity" class="headerlink" title="AppCompatActivity"></a>AppCompatActivity</h3><blockquote><p>  <code>AppCompatActivity</code>继承关系比较深，最终基础类为<code>SupportActivity</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SupportActivity</code>也是返回<code>LifecycleRegistry</code>返回。但是使用的<code>Fragment</code>来监听的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实委托给<code>ReportFragment</code>处理生命周期。</p><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jm93kubtj20rs0mdt9i.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>onActivityCreated</code>方法中调用<code>dispatch</code>方法分发<code>Lifecycle.Event.ON_CREATE</code>事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SupportActivity实现了LifecycleOwner，会调用此代码</span></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SupportActivity</code>实现了<code>LifecycleOwner</code>方法，最终会调用到<code>SupportActivity</code>的<code>mLifecycleRegistry</code>处理事件。<br>类似:</p><ul><li><code>onStart</code>方法中发送<code>Lifecycle.Event.ON_CREATE</code>事件。</li><li><code>onResume</code>方法中发送<code>Lifecycle.Event.ON_RESUME</code>事件。</li><li><code>onPause</code>方法中发送<code>Lifecycle.Event.ON_PAUSE</code>事件。</li><li><code>onStop</code>方法中发送<code>Lifecycle.Event.ON_STOP</code>事件。</li><li><code>onDestroy</code>方法中发送<code>Lifecycle.Event.ON_DESTROY</code>事件。</li></ul><p><code>SupportActivity</code>通过<code>ReportFragment</code>间接处理生命周期的监听。</p><p>但还有个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>onSaveInstanceState()</code>保存<code>AppCompatActivity</code>的状态时，在调用ON_START事件之前，UI认为是不可变的。在<code>onSaveInstanceState()</code>之后才会调用<code>AppCompatActivity</code>的onStop()方法，在不允许UI状态更改，但是<code>Lifecycle</code>尚未移到CREATED状态(<code>AppCompatActivity</code>的<code>onStop()</code>方法尚未调用)的存在间隙。<br>为了防止UI变更，因此这里标记了状态为<code>Lifecycle.State.CREATED</code>。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lifecycle</code>定义了生命周期类。用于派发生命周期。包含三个方法<code>addObserver</code>添加观察者，<code>removeObserver</code>移除观察者，<code>getCurrentState</code>获取当前的状态。</p><p><code>LifecycleRegistry</code>实现了此接口。可以直接使用它来定义自己的<code>LifecycleOwner</code>。</p><h3 id="LifecycleRegistry"><a href="#LifecycleRegistry" class="headerlink" title="LifecycleRegistry"></a>LifecycleRegistry</h3><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jmdy9c10j20rs0k6dgs.jpg" alt=""></p><p>我们先跟踪事件处理的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class LifeycycleFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> val mLifecycleObserver: LifecycleObserver = GenericLifecycleObserver &#123; source, event -&gt;</span><br><span class="line">        Log.d(<span class="string">"LifeycycleFragment"</span>, <span class="string">"source:$source event:$event"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycle.addObserver(mLifecycleObserver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override fun <span class="title">onCreateView</span><span class="params">(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?)</span>: View? </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_lifecycle, container, <span class="keyword">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override fun <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lifecycle.removeObserver(mLifecycleObserver)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只是简单的在<code>Fragment</code>的<code>onCreate</code>方法中添加了<code>LifecycleObserver</code>。</p><p>从<code>Fragment</code>的<code>perfromCreate</code>方法：</p><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jmgka5p5j20rs0jxwei.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ······</span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">    ······</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performCreate</code>有两个功能，一个是调用<code>onCreate</code>方法，一个处理生命周期的事件。</p><p>我们先分析<code>onCreate</code>方法。</p><p>我们的<code>LifeFragment</code>复写了<code>onCreate</code>并添加了生命周期的观察者。</p><p>我们来分析添加观察者的逻辑。</p><h3 id="LifecycleRegistry-添加观察者"><a href="#LifecycleRegistry-添加观察者" class="headerlink" title="LifecycleRegistry 添加观察者"></a>LifecycleRegistry 添加观察者</h3><p>LifecycleRegistry :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先根据当前的状态获取初始化的状态，创建<code>ObserverWithState</code>对象。因为还未处理状态，所以mState的状态为INITIALIZED，初始化的状态也为INITIALIZED。</li><li><code>mObserverMap</code>调用putIfAbsent添加<code>ObserverWithState</code>对象。如果存在就返回原来的对象，因为这里是第一次添加，因此返回的值为null。</li><li>通过<code>mLifecycleOwner</code>（弱引用）获取<code>LifecycleOwner</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mAddingObserverCounter</code>表示有多少个正在添加，<code>mHandlingEvent</code>是否有事件正在处理。这两个变量很奇怪，看似是为了支持多线程，但是又没有同步同步锁，又没有<code>volatile</code>修饰，只能说明不支持多线程操作，只能在UI线程中操作，一次添加一个观察者，一次只能处理一个事件。因此这两个变量很奇怪。isReentrance肯定是false。</p><p>接着是调用<code>calculateTargetState</code>方法计算目标的状态，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> State <span class="title">calculateTargetState</span><span class="params">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">    State siblingState = previous != <span class="keyword">null</span> ? previous.getValue().mState : <span class="keyword">null</span>;</span><br><span class="line">    State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="number">1</span>)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> min(min(mState, siblingState), parentState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从mObserverMap获取<code>ObserverWithState</code>，并获取<code>ObserverWithState</code>状态。前面说过初始化的状态为INITIALIZED。而mState也为INITIALIZED。没有操作mParentStates，其数据parentState为null。最终<code>calculateTargetState</code>计算的目标状态为INITIALIZED。</p><p>由于statefulObserver.mState的状态与targetState所以<code>addObserver</code>不会执行while语句。</p><p>由于isReentrance为false。因此会执行<code>sync</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>isSynced</code>判断是否需要进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSynced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    State eldestObserverState = mObserverMap.eldest().getValue().mState;</span><br><span class="line">    State newestObserverState = mObserverMap.newest().getValue().mState;</span><br><span class="line">    <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经添加了观察者，而且仅一个观察者，<code>mObserverMap.eldest()</code>与<code>mObserverMap.newest()</code>，并且状态与mState相同，因此此方法返回true。<br>因此呢<code>sync</code>方法的while语句也不会执行。</p><p>至此，我们的<code>addObserver</code>已经分析完成。</p><h3 id="LifecycleRegistry-事件处理"><a href="#LifecycleRegistry-事件处理" class="headerlink" title="LifecycleRegistry 事件处理"></a>LifecycleRegistry 事件处理</h3><p>接下来我们分析一下<code>handleLifecycleEvent(Lifecycle.Event.ON_CREATE)</code>的流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123;</span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>getStateAfter</code>方法获取状态，其次是调用<code>moveToState</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                <span class="keyword">return</span> CREATED;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                <span class="keyword">return</span> STARTED;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                <span class="keyword">return</span> RESUMED;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                <span class="keyword">return</span> DESTROYED;</span><br><span class="line">            <span class="keyword">case</span> ON_ANY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected event value "</span> + event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>getStateAfter</code>根据事件获取到状态，此时我们的event为ON_CREATE，因此我们获取的状态为CREATED。</p><p>接下来是<code>moveToState</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mState为INITIALIZED，next为CREATED，不会直接返回，接着我们修改当前状态变量mState。没有事件正在处理mHandlingEvent为false，也没有正在添加观察者，<code>mAddingObserverCounter为0</code>，不会直接返回。</p><p>接着调用<code>sync</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ······</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用isSynced，由于mState为INITIALIZED，但是呢mObserverMap中的ObserverWithState对象为INITIALIZED，因此返回false。接着执行while语句。由于INITIALIZED小于CREATED，因此会调用<code>forwardPass</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">            mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的功能是获取观察者的Iterator，并遍历Iterator比较状态，调用<code>ObserverWithState</code>对象分发事件。</p><p>其中有一个关键的方法<code>upEvent</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">upEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_START;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据状态获取事件，我们传递的是observer.mState为INITIALIZED。因此获取的事件为ON_CREATE。</p><p><code>upEvent</code>方法对应还有<code>downEvent</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title">downEvent</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_DESTROY;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_STOP;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">return</span> ON_PAUSE;</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected state value "</span> + state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法的逻辑总结为如下的状态图。</p><ul><li><code>upEvent</code>状态值变大发生的事件，比如INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED或者DESTROYED -&gt; CREATED -&gt; STARTED -&gt; RESUMED，这中间发生的事件。</li><li><code>downEvent</code>状态值变小发生的事件。比如RESUMED -&gt; STARTED -&gt; CREATED -&gt; DESTROYED这中间发生的事件。</li></ul><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jmn8oya7j20rs0sl3yu.jpg" alt=""></p><p>对于<code>Fragment</code>的其他生命周期事件的处理可以自行分析，流程基本一致。<br><code>SupportActivity</code>的生命周期也是类似的分析方式，只是生命周期的控制委托给了<code>ReportFragment</code>。原理也是一致。</p><p><strong>注意</strong>: <code>SupportActivity</code>的<code>onSaveInstanceState</code>就会标记生命周期的状态为<code>State.CREATED</code>，并通知观察者的事件ON_STOP，不会等待onStop方法执行。</p><h3 id="LifecycleObserver"><a href="#LifecycleObserver" class="headerlink" title="LifecycleObserver"></a>LifecycleObserver</h3><p>添加<code>LifecycleObserver</code>有下面几种方式</p><ol><li>实现<code>FullLifecycleObserver</code>，<code>GenericLifecycleObserver</code>类。</li><li>实现<code>LifecycleObserver</code>并在方法上使用注解<code>OnLifecycleEvent</code>。<br><code>LifecycleObserver</code>整体结构。</li></ol><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jmoctvbdj20rs0bsq38.jpg" alt=""></p><p><code>LifecycleObserver</code>只是一个简单的类，没有任何的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个疑问是，我们的<code>LifecycleObserver</code>没有任何的接口，事件是如何正确的分发事件的呢？注解<code>LifecycleObserver</code>又是如何起作用的呢？</p><p>上一节我们知道了有事件分发，会调用<code>ObserverWithState</code>的<code>dispatchEvent</code>方法。其实我们通知<code>LifecycleObserver</code>就是<code>ObserverWithState</code>来完成的。</p><p>实现<code>FullLifecycleObserver</code>监听生命周期</p><p><code>FullLifecycleObserver</code>继承自<code>LifecycleObserver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FullLifecycleObserver</span> <span class="keyword">extends</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPause</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">(LifecycleOwner owner)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ObserverWithState</code>会适配<code>LifecycleObserver</code>到相应的<code>GenericLifecycleObserver</code>。我们来分析一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    GenericLifecycleObserver mLifecycleObserver;</span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.getCallback(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，会通过<code>Lifecycling.getCallback</code>的方法来适配<code>LifecycleObserver</code>对象到<code>GenericLifecycleObserver</code>对象。</p><p>那我们来分析一下<code>Lifecycling.getCallback</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycling</span> </span>&#123;</span><br><span class="line">    ······</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> GenericLifecycleObserver <span class="title">getCallback</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> FullLifecycleObserver) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object);</span><br><span class="line">        &#125;</span><br><span class="line">        ······</span><br><span class="line">    &#125;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是<code>FullLifecycleObserver</code>对象，我们是直接通过<code>FullLifecycleObserverAdapter</code>来进行适配。</p><p><code>FullLifecycleObserverAdapter</code>代码很简单，这里不做叙述了。</p><p>所以我们实现了<code>FullLifecycleObserver</code>监听生命周期时，<code>ObserverWithState</code>会适配此观察者为<code>FullLifecycleObserverAdapter</code>，分发事假时调用<code>FullLifecycleObserverAdapter</code>的<code>onStateChanged</code>方法进行分发事件。</p><p>实现<code>GenericLifecycleObserver</code>监听生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycling</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> GenericLifecycleObserver <span class="title">getCallback</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        ······</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> GenericLifecycleObserver) &#123;</span><br><span class="line">            <span class="keyword">return</span> (GenericLifecycleObserver) object;</span><br><span class="line">        &#125;</span><br><span class="line">        ······</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，在构造方法中，会通过<code>Lifecycling.getCallback</code>的方法来适配<code>LifecycleObserver</code>对象到<code>GenericLifecycleObserver</code>对象。因为传递的<code>LifecycleObserver</code>已经是<code>GenericLifecycleObserver</code>对象，所以呢<code>Lifecycling.getCallback</code>直接返回此对象。</p><p>使用<code>OnLifecycleEvent</code>注解监听生命周期</p><p>使用注解的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续分析<code>Lifecycling.getCallback</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> GenericLifecycleObserver <span class="title">getCallback</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">    <span class="keyword">int</span> type = getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors =</span><br><span class="line">                sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            GeneratedAdapter generatedAdapter = createGeneratedAdapter(</span><br><span class="line">                    constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> GeneratedAdapter[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的<code>getCallback</code>的调用流程。</p><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1g0jmoq6njmj20rs0g9q30.jpg" alt=""></p><p>通过<code>getObserverConstructorType</code>方法获取构造的类型，根据此类型来判断使用哪种Adapter来适配。</p><p>接下来分析<code>getObserverConstructorType</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getObserverConstructorType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sCallbackCache.containsKey(klass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sCallbackCache.get(klass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> type = resolveObserverCallbackType(klass);</span><br><span class="line">    sCallbackCache.put(klass, type);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断缓存时候包含Class类型缓存。我们是首次进入此方法时不会包含。<br>接着通过<code>resolveObserverCallbackType</code>方法获取类型。</p><p>我们来一步步分析<code>resolveObserverCallbackType</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveObserverCallbackType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// anonymous class bug:35073837</span></span><br><span class="line">    <span class="keyword">if</span> (klass.getCanonicalName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是匿名内部类，就直接返回<code>REFLECTIVE_CALLBACK</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveObserverCallbackType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Constructor&lt;? extends GeneratedAdapter&gt; constructor = generatedConstructor(klass);</span><br><span class="line">    <span class="keyword">if</span> (constructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sClassToAdapters.put(klass, Collections</span><br><span class="line">                .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor));</span><br><span class="line">        <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>generatedConstructor</code>获取构造方法。<code>generatedConstructor</code>根据Class获取相关类的构造方法，但是<code>GeneratedAdapter</code>接口没有暴露，我们传递的也不会是此接口相关的类，后续版本也许会暴露<code>GeneratedAdapter</code>接口。因此这里不需要分析了，直接返回为null。if语句也就不会执行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveObserverCallbackType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> hasLifecycleMethods = ClassesInfoCache.sInstance.hasLifecycleMethods(klass);</span><br><span class="line">    <span class="keyword">if</span> (hasLifecycleMethods) &#123;</span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>ClassesInfoCache.sInstance.hasLifecycleMethods</code>判断是否有生命周期的方法。接着分析此方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLifecycleMethods</span><span class="params">(Class klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHasLifecycleMethods.containsKey(klass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mHasLifecycleMethods.get(klass);</span><br><span class="line">    &#125;</span><br><span class="line">    Method[] methods = getDeclaredMethods(klass);</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            createInfo(klass, methods);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mHasLifecycleMethods.put(klass, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先缓存里面没有相关的数据，接着通过<code>getDeclaredMethods</code>反射获取Class的方法。接着遍历方法，获取<code>OnLifecycleEvent</code>注解，因为我们是使用注解的方式来管理声明周期的，因此可以方法上可以获取到OnLifecycleEvent。因此会调用createInfo方法，并返回true。createInfo其实是根据Class获取声明OnLifecycleEvent注解的方法，并再次封装成MethodReference，并放入缓存中。这里就不分析代码了。</li><li><code>ClassesInfoCache</code>的方法<code>hasLifecycleMethods</code>返回true -&gt; Lifecycling的 <code>resolveObserverCallbackType</code>返回REFLECTIVE_CALLBACK -&gt; Lifecycling的<code>getObserverConstructorType</code>返回REFLECTIVE_CALLBACK ，那Lifecycling的getCallback将返回<code>ReflectiveGenericLifecycleObserver</code>来进行适配。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>LifecycleOwner</code>只有一个简单的接口，获取<code>Lifecycle</code>，<code>Lifecycle</code>与<code>LifecycleObserver</code>采用的是观察者模式进行组织。</li><li><code>LifecycleRegistry</code>实现Lifecycle接口，可以使用此类来实现自己的生命周期。<code>LifecycleRegistry</code>内存采用了适配器模式，把<code>LifecycleObserver</code>是适配成<code>GenericLifecycleObserver</code>。</li><li><code>LifecycleObserver</code>没有任何接口，我们实现此接口时可以利用注解的方式，生命周期的变更执行响应的方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Jetpack之Lifecycle的源码分析&quot;&gt;&lt;a href=&quot;#Android-Jetpack之Lifecycle的源码分析&quot; class=&quot;headerlink&quot; title=&quot;Android Jetpack之Lifecycle的源码分析&quot;&gt;
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="Jetpack" scheme="http://blog.zoudongq123.cn/tags/Jetpack/"/>
    
      <category term="源码分析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife源码分析</title>
    <link href="http://blog.zoudongq123.cn/2018/10/05/ButterKnife%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zoudongq123.cn/2018/10/05/ButterKnife源码分析/</id>
    <published>2018-10-05T02:25:56.000Z</published>
    <updated>2019-03-16T09:26:29.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ButterKnife源码分析"><a href="#ButterKnife源码分析" class="headerlink" title="ButterKnife源码分析"></a>ButterKnife源码分析</h1><blockquote><p>基于 ButterKnife 8.8.0版本进行分析</p></blockquote><h2 id="ButterKnife-使用"><a href="#ButterKnife-使用" class="headerlink" title="ButterKnife 使用"></a>ButterKnife 使用</h2><h3 id="依赖说明"><a href="#依赖说明" class="headerlink" title="依赖说明"></a>依赖说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation &apos;com.jakewharton:butterknife:8.8.1&apos;</span><br><span class="line">  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@BindView</span>(R.id.user) EditText username;</span><br><span class="line">  <span class="meta">@BindView</span>(R.id.pass) EditText password;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BindString</span>(R.string.login_error) String loginErrorMessage;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnClick</span>(R.id.submit) <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO call server...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// TODO Use fields...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多模块使用"><a href="#多模块使用" class="headerlink" title="多模块使用"></a>多模块使用</h3><blockquote><p>在Library 中使用ButterKnife 以上操作是无法使用的 ，我们还需要借助<code>Butterknife插件</code>来实现功能</p></blockquote><p>在您的<strong>root build.gradle</strong>文件中buildscript:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    google()</span><br><span class="line">   &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.jakewharton:butterknife-gradle-plugin:8.8.1&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="添加插件-apply"><a href="#添加插件-apply" class="headerlink" title="添加插件  apply"></a>添加插件  apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;com.jakewharton.butterknife&apos;</span><br></pre></td></tr></table></figure><h4 id="插件使用Butterknife"><a href="#插件使用Butterknife" class="headerlink" title="插件使用Butterknife"></a>插件使用Butterknife</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ExampleActivity extends Activity &#123;</span><br><span class="line">  @BindView(R2.id.user) EditText username;</span><br><span class="line">  @BindView(R2.id.pass) EditText password;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h3><ul><li><p>在Library中无法使用在注解中无法使用R的资源</p><blockquote><p> 原因很简单，因为Lib模块中 java注解无法使用变量 然而lib生成的R 文件资源都是 <code>public static</code> 不是 <code>public static final</code>  简单的说lib中生成的R文件不是常量</p></blockquote><p> 编译器将会报错：Attribute value must be constant ，如下图：<br> <img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0h9wcdpzcj20d002c755.jpg" alt=""></p></li></ul><p><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">Butterknife 官网简单使用说明</a></p><h2 id="ButterKnife源码分析-1"><a href="#ButterKnife源码分析-1" class="headerlink" title="ButterKnife源码分析"></a>ButterKnife源码分析</h2><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">源码地址</a></h3><h3 id="源码module结构"><a href="#源码module结构" class="headerlink" title="源码module结构"></a>源码module结构</h3><h4 id="组件依赖关系"><a href="#组件依赖关系" class="headerlink" title="组件依赖关系"></a>组件依赖关系</h4><blockquote><p>ButterKnife 共7个组件，他们的依赖关系如下图所示 butterknife-integration-test；该项目的测试用例–不做介绍</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/882b6a2aly1fznagq9al6j20iv0bwt8n.jpg" alt=""></p><ul><li>butterknife：这个工程提供了 ButterKnife.bind(this)，这是 ButterKnife 对外提供的门面。也是运行时，触发 Activity 中 View 控件绑定的时机,提供android使用的API。</li><li>butterknife-compiler：java－model 编译期间将使用该工程，他的作用是解析注解，并且生成 Activity 中 View 绑定的 Java 文件。</li><li>butterknife-annotations：java－model 将所有自定义的注解放在此工程下， 确保职责的单一。</li><li>butterknife-gradle-plugin：gradle 插件，这是8.2.0版本起为了支持 library 工程而新增的一个插件工程。</li><li>butterknife-lint：针对 butterknife-gradle-plugin 而做的静态代码检查工具，非常有态度的一种做法，在下文做详细介绍。</li></ul><h3 id="编译-生成Java代码"><a href="#编译-生成Java代码" class="headerlink" title="编译 生成Java代码"></a>编译 生成Java代码</h3><blockquote><p>前提以上基本用法已经加入工程</p></blockquote><h5 id="简单使用-1"><a href="#简单使用-1" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.btn1)</span><br><span class="line">    Button btn;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv1)</span><br><span class="line">    TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick</span>(R.id.btn1)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"Butterknfie 简单使用"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Butterknife-之-编译期"><a href="#Butterknife-之-编译期" class="headerlink" title="Butterknife 之 编译期"></a>Butterknife 之 编译期</h4><blockquote><p>android-apt(Annotation Processing Tool) ，在Java代码的编译时期，javac 会调用java注解处理器来生成辅助代码。生成的代码就在 <code>build/generated/source/apt</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> T target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view2131427416;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> T target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.btn1, <span class="string">"field 'btn' and method 'btnClick'"</span>);</span><br><span class="line">    <span class="comment">//这里的 target 其实就是我们的 Activity</span></span><br><span class="line">    <span class="comment">//这个castView就是将得到的View转化成具体的子View</span></span><br><span class="line">    target.btn = Utils.castView(view, R.id.btn1, <span class="string">"field 'btn'"</span>, Button.class);</span><br><span class="line">    view2131427416 = view;</span><br><span class="line">    <span class="comment">//为按钮设置点击事件</span></span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.btnClick();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    target.tv = Utils.findRequiredViewAsType(source, R.id.tv1, <span class="string">"field 'tv'"</span>, TextView.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line"></span><br><span class="line">    target.btn = <span class="keyword">null</span>;</span><br><span class="line">    target.tv = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    view2131427416.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view2131427416 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Utils.findRequiredView 方法的封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.findRequiredView</span></span><br><span class="line"> View view = source.findViewById(id);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Butterknife-之-android-apt-Annotation-Processing-Tool"><a href="#Butterknife-之-android-apt-Annotation-Processing-Tool" class="headerlink" title="Butterknife 之 android-apt(Annotation Processing Tool)"></a>Butterknife 之 android-apt(Annotation Processing Tool)</h3><blockquote><p> APT(Annotation Processing Tool)，即注解处理工具。在该方案中，通常有个必备的三件套，分别是注解处理器 Processor，注册注解处理器 AutoService 和代码生成工具 JavaPoet。</p></blockquote><h4 id="注解处理器-Processor"><a href="#注解处理器-Processor" class="headerlink" title="注解处理器 Processor"></a>注解处理器 Processor</h4><blockquote><p>ButterKnife 一切皆注解，因此首先需要个处理器来解析注解。 ButterKnifeProcessor 充当了该角色，其中 process 方法是触发注解解析的入口，所有的神奇的事情从这里发生。<br>process 方法中主要做两件事情，分别是：</p></blockquote><ul><li>解析所有包含了 ButterKnife 注解的类</li><li>根据解析结果，使用 JavaPoet 生成相应的Java文件<br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hbw37sx4j214k0j8n0q.jpg" alt="ButterKnifeProcessor#process源码"></li></ul><p><code>findAndParseTargets(env)</code> 中解析注解的代码非常冗长，依次对 <code>@BindArray</code> 、<code>@BindColor</code>、<code>@BindString</code>、<code>@BindView</code> 等注解进行解析，解析结果存放在  bindingMap  中。</p><p>这里重点关注下 bindingMap 的键值对。key 值为 TypeElement 对象 ，可以简单的理解为被解析的类本身，而 value 值为 BindingSet 对象，该对象存放了解析结果，根据该结果，JavaPoet 将生成不同的 Java 文件，</p><p>以官方 sample 为例，其映射关系如下：</p><table><thead><tr><th>key</th><th>value</th><th>JavaPoet 根据 value 生成的文件</th></tr></thead><tbody><tr><td>SimpleActivity</td><td>BindingSet</td><td>SimpleActivity_ViewBinding.java</td></tr><tr><td>SimpleAdapter</td><td>BindingSet</td><td>SimpleAdapter$ViewHolder_ViewBinding.java</td></tr></tbody></table><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hc6tnm3rj21340n4n7y.jpg" alt=""></p><h4 id="注册注解处理器-AutoService"><a href="#注册注解处理器-AutoService" class="headerlink" title="注册注解处理器 AutoService"></a>注册注解处理器 <a href="https://link.jianshu.com/?t=https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener">AutoService</a></h4><blockquote><p>定义完注解处理器后，还需要告诉编译器该注解处理器的信息，需在 <code>src/main/resource/META-INF/service</code> 目录下增加   <code>javax.annotation.processing.Processor</code> 文件，并将注解处理器的类名配置在该文件中。</p></blockquote><p>整个过程比较繁琐，Google 为我们提供了更便利的工具，叫 <code>AutoService</code>，此时只需要为注解处理器增加 <code>@AutoService</code> 注解就可以了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[注] [AutoService使用的是<code>java.util.ServiceLoader</code>]</p><h4 id="Java编写器-JavaPoet"><a href="#Java编写器-JavaPoet" class="headerlink" title="Java编写器 JavaPoet"></a>Java编写器 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a></h4><blockquote><p>了解 JavaPoet ，最好的方式便是看<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">官方文档</a>。简而言之，当我们写一个类时，其实是有固定结构的，JavaPoet 提供了生成这些结构的 api</p></blockquote><p>举例如下：</p><ul><li><p>类：TypeSpec.classBuilder()</p></li><li><p>构造器：MethodSpec.constructorBuilder()</p></li><li><p>方法：MethodSpec.methodBuilder()</p></li><li><p>参数：ParameterSpec.builder()</p></li><li><p>属性：FieldSpec.builder()</p></li><li><p>程序片段：CodeBlock.builder()</p><p>以 ButterKnife 而言，他做的事情便是将注解处理器解析后的结果（实际上就是上文提到的 BindingSet 对象）生成 Activity_ViewBinding.java，该对象负责绑定 Activity 中的 View 控件以及设置监听器等。</p><p>那么 JavaPoet 是如何处理的？实际上 ButterKnife 会将上文提到的 BindingSet 转换成类似于下文所示的代码：<br>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line">TypeSpec typeSpec = TypeSpec.classBuilder(<span class="string">"TestActivity_ViewBinding"</span>)</span><br><span class="line">        .addModifiers(PUBLIC) <span class="comment">// 类为public</span></span><br><span class="line">        .addSuperinterface(UNBINDER) <span class="comment">// 类为Unbinder的实现类</span></span><br><span class="line">        .addField(targetField) <span class="comment">// 生成属性 private TestActivity target</span></span><br><span class="line">        .addMethod(constructorForActivity) <span class="comment">// 生成构造器1</span></span><br><span class="line">        .addMethod(otherConstructor) <span class="comment">// 生成构造器2</span></span><br><span class="line">        .addMethod(unBindeMethod) <span class="comment">// 生成unbind()方法</span></span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 生成 Java 文件</span></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.zdg"</span>, typeSpec)<span class="comment">//包名和类</span></span><br><span class="line">        .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)</span><br><span class="line">        .build();</span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure></li></ul><p>最后总结下这三件套的协作流程，如下图:</p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hcpb81duj20bd0it41b.jpg" alt=""></p><h3 id="Butterknife-之-运行期"><a href="#Butterknife-之-运行期" class="headerlink" title="Butterknife 之 运行期"></a>Butterknife 之 运行期</h3><blockquote><p>接下来我们来分析下运行期间发生的事情，相比于编译期间，运行期间的逻辑简单了许多。继续使用上面的Demo例子</p></blockquote><p>运行时的入口在于 <code>ButterKnife.bind(this)</code>，追溯源码发现，最终将会执行以下逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终将找到 SimpleActivity_ViewBinding 的构造器，并实例化</span></span><br><span class="line">Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line">constructor.newInstance(target, source);</span><br></pre></td></tr></table></figure></p><p>也就是说 ButterKnife.bind(this) 等价于如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View sourceView = activity.getWindow().getDecorView();</span><br><span class="line"><span class="keyword">new</span> SimpleActivity_ViewBinding(activity,sourceView);</span><br></pre></td></tr></table></figure><p>注：虽然这里使用了反射，但源码中将 <code>Class.forName</code> 的结果缓存起来后再通过 <code>newInstance</code> 创建实例，避免重复加载类，提升性能。</p><p>编译期间和运行期间相辅相成，这便是 android-apt 的普遍套路。</p><h3 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h3><blockquote><p>编译时和运行时的问题解决了，还有最后一个问题：由 R 生成 R2 的意义是什么？</p></blockquote><p>如果你细心的话会发现在官方的 sample-library 中，注解的值均是由 R2 来引用的，如下图：<br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hd2kvbtsj20ik041q62.jpg" alt=""></p><p>如果非 library 工程，则仍然引用系统生成的 R 文件。所以可以猜测：R2 的诞生是为 library 工程量身打造的。</p><p><code>在上面我说过R文件的问题，library中生成的R文件资源文件不是常量 无法使用注解</code></p><p><code>JakeWharton大神</code>他是怎么解决这个问题呢？？？</p><blockquote><p>既然 R 不能满足要求，那就自己构建一个 R2，由 R 复制而来，并且将其属性都修改为 public static final 来修饰的常量。为了让使用者对整个过程无感知，因此使用 gradle 插件来解决这个需求，这也是 <code>butterknife-gradle-plugin</code> 工程的由来。</p></blockquote><h4 id="butterknife-gradle-plugin"><a href="#butterknife-gradle-plugin" class="headerlink" title="butterknife-gradle-plugin"></a>butterknife-gradle-plugin</h4><p><code>butterknife-gradle-plugin</code> 有两个重要的第三方依赖，分别是 <code>javaparser</code> 和 <code>javapoet</code> ，前者用于解析 Java 文件，也就是解析 R 文件，后者用于将解析结果生成 R2 文件。<br>整个插件工程的源码并不难理解，在生成 R2 文件时，要将属性定义成 public static final ，在源码中我们可以看到此逻辑，在 FinalRClassBuilder.addResourceField() 中 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec.Builder fieldSpecBuilder = FieldSpec.builder(<span class="keyword">int</span>.class, fieldName)</span><br><span class="line">        .addModifiers(PUBLIC, STATIC, FINAL)</span><br><span class="line">        .initializer(fieldValue);</span><br></pre></td></tr></table></figure><p><code>butterknife</code> 插件在 <code>processResources</code> 的 Task 中执行，该任务通常用来完成文件的 copy。</p><p>有关插件的编写 大家可以查看其他插件编写教程</p><h4 id="JakeWharton-给ButterKnife-的情怀和态度——butterknife-lint"><a href="#JakeWharton-给ButterKnife-的情怀和态度——butterknife-lint" class="headerlink" title="JakeWharton 给ButterKnife 的情怀和态度——butterknife-lint"></a>JakeWharton 给ButterKnife 的情怀和态度——butterknife-lint</h4><blockquote><p>一个静态代码检查工具，用来验证非法的 R2 引用。一旦在我们的业务项目里不小心引用了 R2 文件，</p></blockquote><p>当执行 Lint 后，将会有如下图的提示信息：</p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hdkrf91gj21mu0bswmk.jpg" alt=""></p><p><a href="https://www.jianshu.com/p/b8b59fb80554" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ButterKnife源码分析&quot;&gt;&lt;a href=&quot;#ButterKnife源码分析&quot; class=&quot;headerlink&quot; title=&quot;ButterKnife源码分析&quot;&gt;&lt;/a&gt;ButterKnife源码分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于 Bu
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码分析</title>
    <link href="http://blog.zoudongq123.cn/2018/09/11/Retrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zoudongq123.cn/2018/09/11/Retrofit源码分析/</id>
    <published>2018-09-11T01:25:10.000Z</published>
    <updated>2019-03-16T09:25:36.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><blockquote><p> A type-safe HTTP client for Android and Java</p></blockquote><p>开发Android App肯定会使用Http请求与服务器通信，上传或下载数据等。目前开源的Http请求工具也有很多，比如Google开发的<code>Volley</code>，loopj的<code>Android Async Http</code>，Square开源的<code>OkHttp</code>或者<code>Retrofit</code>等。</p><p>我觉得Retrofit 无疑是这几个当中最好用的一个，设计这个库的思路很特别而且巧妙。Retrofit的代码很少，花点时间读它的源码肯定会收获很多。</p><p>本文的源码分析基于Retrofit 2，和Retrofit 1.0的Api有较大的不同， 本文主要分为几部分：<code>Retrofit 是什么</code>，<code>Retrofit怎么用</code>，<code>Retrofit的原理是什么</code></p><h2 id="Retorift-使用"><a href="#Retorift-使用" class="headerlink" title="Retorift 使用"></a>Retorift 使用</h2><h3 id="官方使用简介"><a href="#官方使用简介" class="headerlink" title="官方使用简介"></a>官方使用简介</h3><blockquote><p>官方使用简介:(<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a>)</p></blockquote><h3 id="引用依赖"><a href="#引用依赖" class="headerlink" title="引用依赖"></a>引用依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 最新版本 ：2.5.0</span><br><span class="line">implementation &apos;com.squareup.retrofit2:retrofit:(insert latest version)&apos;</span><br></pre></td></tr></table></figure><h3 id="生成一个ApiService"><a href="#生成一个ApiService" class="headerlink" title="生成一个ApiService"></a>生成一个ApiService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Retorfit"><a href="#创建Retorfit" class="headerlink" title="创建Retorfit"></a>创建Retorfit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步请求</span></span><br><span class="line"><span class="comment">// 请求数据，并且处理response</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//同步请求</span></span><br><span class="line">call.execute()</span><br></pre></td></tr></table></figure><h3 id="ApiService-配置"><a href="#ApiService-配置" class="headerlink" title="ApiService 配置"></a>ApiService 配置</h3><h4 id="Url配置"><a href="#Url配置" class="headerlink" title="Url配置"></a>Url配置</h4><table><thead><tr><th>注解</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>@GET</td><td>get请求</td><td>@GET(“group/users”)</td></tr><tr><td>@POST</td><td>post请求</td><td>@POST(“group/users”)</td></tr><tr><td>@Uri</td><td>Uri全连接配合 其他请求方法</td><td>@Uri(“<a href="http://xxxx/group/users" target="_blank" rel="noopener">http://xxxx/group/users</a>“)</td></tr><tr><td>@PATH</td><td>get/post 请求的动态路径，用于方法参数注解</td><td>@GET(“group/{id}/users”    Call<list<user>&gt; groupList(@Path(“id”) int groupId);</list<user></td></tr><tr><td>@Headers</td><td>请求的 HEADER 作用于方法</td><td>@Headers(“Cache-Control: max-age=640000”)</td></tr><tr><td>@Header</td><td>请求的 HEADER 作用于方法参数</td><td>@Header(“Authorization”) String authorization</td></tr><tr><td>@Query &amp; @QueryMap</td><td>用于方法参数注解,只能配合@GET</td><td>Call<list<user>&gt; groupList(@Path(“id”) int groupId,@Query(“sort”) String sort);</list<user></td></tr><tr><td>@Body</td><td>用于方法参数注解</td><td>@POST(“users/new”)Call<user> createUser(@Body User user);</user></td></tr><tr><td>@Field &amp; @FieldMap</td><td>用于方法参数注解,只能配合@POST</td><td>类似@Query &amp; @QueryMap</td></tr><tr><td>@Part &amp; @PartMap</td><td>用于POST文件上传</td><td>Call<user> updateUser(@Part(“photo”) RequestBody photo, @Part(“description”) RequestBody description);</user></td></tr></tbody></table><h3 id="其他高级用法"><a href="#其他高级用法" class="headerlink" title="其他高级用法"></a>其他高级用法</h3><p>  官方使用简介:(<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a>)</p><h2 id="Retrofit-源码分析"><a href="#Retrofit-源码分析" class="headerlink" title="Retrofit 源码分析"></a>Retrofit 源码分析</h2><blockquote><p>retrofit的最大特点就是解耦，要解耦就需要大量的设计模式，假如一点设计模式都不懂的人，可能很难看懂retrofit。</p></blockquote><h3 id="基本流程-组装过程）"><a href="#基本流程-组装过程）" class="headerlink" title="基本流程(组装过程）"></a>基本流程(组装过程）</h3><h4 id="Retrofit-create"><a href="#Retrofit-create" class="headerlink" title="Retrofit#create"></a>Retrofit#create</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApiService service = retrofit.create(ApiService.class);</span><br></pre></td></tr></table></figure><p>Retrofit是如何创建Api的，是通过<code>Retrofit#create()</code>的方法 ,通过<a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">动态代理</a>方式。</p><p>关于动态代理 这里就不多讲了，楼下有动态代理链接，至于为什么用动态代理，大家想一想？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//DefaultMethod 是 Java 8 的概念，是定义在 interface 当中的有实现的方法</span></span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//每一个接口最终实例化成一个 ServiceMethod，并且会缓存</span></span><br><span class="line">             </span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">            (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            <span class="comment">//Retrofit 与 OkHttp 完全耦合</span></span><br><span class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="comment">//发起请求，并解析服务端返回的结果</span></span><br><span class="line">            <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 提取在create方法中的关键几行代码 <code>Service Proxy</code></p><p>当大家了解了动态代理之后， 都知道我们调用ApiService中的<code>method</code>都会自动调用 <code>InvocationHandler()</code>.</p><p>真真开始执行的是 <code>serviceMethod.adapt(okHttpCall)==&gt; calladapter#adapt(okhttpCall);</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">             (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line"> OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><p>一个 ServiceMethod 对象对应于一个 API interface 的一个方法，loadServiceMethod(method) 方法负责加载 ServiceMethod：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了缓存逻辑，同一个 API 的同一个方法，只会创建一次。这里由于我们每次获取 API 实例都是传入的 class 对象，而 class 对象是进程内单例的，所以获取到它的同一个方法 Method 实例也是单例的，所以这里的缓存是有效的。</p><p><code>ServiceMethod</code>是什么呢？？？里面包含什么 ???<br>大致就是想这个方法的method转化成 <code>ServiceMethod对象</code> 包含 各个注解（方法的注解，参数的注解，方法的返回值的东西）,那我们来看下具体有什么东西</p><p>我们看看 <code>ServiceMethod</code> 的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">    <span class="keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">    <span class="keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">    <span class="keyword">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">    <span class="keyword">this</span>.headers = builder.headers;</span><br><span class="line">    <span class="keyword">this</span>.contentType = builder.contentType;</span><br><span class="line">    <span class="keyword">this</span>.hasBody = builder.hasBody;</span><br><span class="line">    <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">    <span class="keyword">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">    <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了buider 模式，这里很多参数，有的参数一看就明白 像baseUrl，headers ，contyentType等，讲解主要关注四个成员：callFactory，callAdapter，responseConverter 和 parameterHandlers。</p><ul><li>callFactory 负责创建 HTTP 请求，HTTP 请求被抽象为了 okhttp3.Call 类，它表示一个已经准备好，可以随时执行的 HTTP 请求；</li><li>callAdapter 把 retrofit2.Call<t> 转为 T（注意和 okhttp3.Call 区分开来，retrofit2.Call<t> 表示的是对一个 Retrofit 方法的调用），这个过程会发送一个 HTTP 请求，拿到服务器返回的数据（通过 okhttp3.Call 实现），并把数据转换为声明的 T 类型对象（通过 Converter<f, t=""> 实现）；</f,></t></t></li><li>responseConverter 是 Converter<responsebody, t=""> 类型，负责把服务器返回的数据（JSON、XML、二进制或者其他格式，由 ResponseBody 封装）转化为 T 类型的对象；</responsebody,></li><li>parameterHandlers 则负责解析 API 定义时每个方法的参数，并在构造 HTTP 请求时设置参数；</li></ul><p><code>retrofit2.ServiceMethod.Builder#build()</code>方法中生成了以上对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过method 找到对应的retrofit2.CallAdapter</span></span><br><span class="line">    callAdapter = createCallAdapter();</span><br><span class="line">     <span class="comment">//省略代码...</span></span><br><span class="line">    <span class="comment">// 通过method 找到对应的retrofit2.Converter</span></span><br><span class="line">    responseConverter = createResponseConverter();</span><br><span class="line">     <span class="comment">//省略代码...</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">      <span class="comment">//解析 请求的方法</span></span><br><span class="line">        parseMethodAnnotation(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">      parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">        Type parameterType = parameterTypes[p];</span><br><span class="line">         <span class="comment">//省略代码...</span></span><br><span class="line">        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//解析方法参数注解</span></span><br><span class="line">        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//省略代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### CallAdapter</span><br><span class="line">&gt; retrofit2.Retrofit.Builder#addCallAdapterFactory(Factory)</span><br><span class="line"></span><br><span class="line">默认 retrofit2.DefaultCallAdapterFactory 使用的是OkhttpCall</span><br><span class="line">+ `retrofit2.ServiceMethod.Builder#createCallAdapter(...)`</span><br><span class="line">    +  `retrofit2.Retrofit#callAdapter(...)`</span><br><span class="line">    +  `retrofit2.Retrofit#nextCallAdapter(null,...)`</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      <span class="comment">// 调用retrofit2.CallAdapter.Factory#get</span></span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略代码</span></span><br><span class="line">    <span class="comment">//throw new IllegalArgumentException(builder.toString());</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面知道如果注册了多个<code>retrofit2.CallAdapter</code>,按照注册的顺序来执行，如果那个有返回值就会直接返回，不走for循环了</p><h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><blockquote><p>通过Retrofit 添加ConverterFactory<br><code>Retrofit.Builder#addConverterFactory(Factory)</code></p></blockquote><p> 默认<code>retrofit2.BuiltInConverters</code></p><h4 id="ParameterHandlers-or-RequestConverter"><a href="#ParameterHandlers-or-RequestConverter" class="headerlink" title="ParameterHandlers or RequestConverter"></a>ParameterHandlers or RequestConverter</h4><ul><li><code>retrofit2.ServiceMethod.Builder#parseParameter(...)</code></li><li><code>retrofit2.ServiceMethod.Builder#parseParameterAnnotation(...)</code><ul><li><code>retrofit2.Retrofit#stringConverter(...)</code><ul><li><code>retrofit2.Converter.Factory#stringConverter(...)</code></li><li>OR <code>retrofit2.Converter.Factory#requestBodyConverter(...)</code></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">        <span class="keyword">int</span> p, Type parameterType, Annotation[] annotations) &#123;</span><br><span class="line">      ParameterHandler&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">//关键代码</span></span><br><span class="line">        ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(</span><br><span class="line">            p, parameterType, annotations, annotation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (annotationAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略代码  ...</span></span><br><span class="line"></span><br><span class="line">        result = annotationAction;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="comment">//省略代码 ...</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameterAnnotation(<span class="keyword">int</span> p, Type type, Annotation[] annotations, Annotation annotation) &#123;</span><br><span class="line">  <span class="comment">// 关键代码</span></span><br><span class="line">  Converter&lt;?, String&gt; converter =</span><br><span class="line">              retrofit.stringConverter(iterableType, annotations);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  Converter&lt;?, RequestBody&gt; converter =</span><br><span class="line">                retrofit.requestBodyConverter(type, annotations, methodAnnotations);</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> ParameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【总结】: 当执行<code>retrofit2.Retrofit#create(final Class&lt;T&gt; service)</code>的时候就会找到对应的 <code>retrofit2.Converter</code></p><h4 id="responseConverter"><a href="#responseConverter" class="headerlink" title="responseConverter"></a>responseConverter</h4><ul><li><code>retrofit2.ServiceMethod.Builder#createResponseConverter(...)</code><ul><li><code>retrofit2.Retrofit#responseBodyConverter(...)</code></li><li><code>retrofit2.Retrofit#nextResponseBodyConverter(null,...)</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      <span class="comment">// 调用 retrofit2.Converter.Factory#responseBodyConverter</span></span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//省略代码</span></span><br><span class="line">    <span class="comment">// throw new IllegalArgumentException(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面知道如果注册了多个Converter 按照注册的顺序来执行，如果那个有返回值就会直接返回，不走for循环了</p><p>【总结】: 当执行<code>retrofit2.Retrofit#create(final Class&lt;T&gt; service)</code>的时候就会找到对应的 <code>retrofit2.Converter</code></p><p><strong>以上都是初始化操作，将所有的请求相关的东西都封装到<code>ServiceMethod</code>中</strong></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><p>真正执行的开始点就是<code>serviceMethod.adapt</code> ,<strong>ServiceMethod.class</strong>执行过程中的 三个很重要，也是整个过程关键节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单粗俗的讲：返回包装okhttpCall后的对象</span></span><br><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//retrofit2.OkHttpCall#createRawCall 调用</span></span><br><span class="line">okhttp3.<span class="function">Call <span class="title">toCall</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 okhttp.Call</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//retrofit2.OkHttpCall 请求结果之后 会调用 responseBody  convert</span></span><br><span class="line"><span class="function">R <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>serviceMethod</code>上面三个方法,将 <code>OkhttpCall</code>,<code>CallAdapter</code> ,<code>Converter</code> 关联起来</strong></p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g0hirf70mqj20or0nen2d.jpg" alt=""></p><p>为什么要用动态代理？</p><p>因为对接口的所有方法的调用都会集中转发到 InvocationHandler#invoke函数中，我们可以集中进行处理，更方便了。你可能会想，我也可以手写这样的代理类，把所有接口的调用都转发到 InvocationHandler#invoke，当然可以，但是可靠地自动生成岂不更方便,可以方便为什么不方便。</p><p><a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></p><p><a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">Java动态代理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Retrofit&quot;&gt;&lt;a href=&quot;#Retrofit&quot; class=&quot;headerlink&quot; title=&quot;Retrofit&quot;&gt;&lt;/a&gt;Retrofit&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; A type-safe HTTP client for Andr
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析 Interceptor</title>
    <link href="http://blog.zoudongq123.cn/2018/08/20/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)/"/>
    <id>http://blog.zoudongq123.cn/2018/08/20/OkHttp源码分析(三)/</id>
    <published>2018-08-20T02:11:24.000Z</published>
    <updated>2019-03-16T09:32:54.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp源码分析-Interceptor"><a href="#OkHttp源码分析-Interceptor" class="headerlink" title="OkHttp源码分析 Interceptor"></a>OkHttp源码分析 Interceptor</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(<span class="keyword">new</span> LoggingInterceptor())</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line"></span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个重要的方法<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request request = chain.request();</span><br><span class="line">Response response = chain.proceed(request);</span><br></pre></td></tr></table></figure></p><p><code>OkHttpClient.Builder</code> 提供了两个 不同的<strong>拦截器组</strong> </p><ul><li>Interceptor（Application Interceptor）</li><li>NetworkInterceptor（Network Interceptor）</li></ul><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14rd19tl1j20go0fa3zg.jpg" alt="okhttp-interceptor"></p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14rc8lfoij218a0km7ie.jpg" alt=""></p><h2 id="Interceptor的始发站-getResponseWithInterceptorChain"><a href="#Interceptor的始发站-getResponseWithInterceptorChain" class="headerlink" title="Interceptor的始发站 getResponseWithInterceptorChain"></a>Interceptor的始发站 <code>getResponseWithInterceptorChain</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// AppInterceptor</span></span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">   <span class="comment">// NetWorkInterceptor</span></span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interceptor 列表  <code>AppInterceptor</code> ,<code>RetryAndFollowUpInterceptor</code>,<code>BridgeInterceptor</code>,<code>CacheInterceptor</code>,<code>ConnectInterceptor</code>,<code>NetworkInterceptor</code>,<code>CallServerInterceptor</code></p><h2 id="RealInterceptorChain-执行链式调用"><a href="#RealInterceptorChain-执行链式调用" class="headerlink" title="RealInterceptorChain 执行链式调用"></a>RealInterceptorChain 执行链式调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chain is RealInterceptorChain</span></span><br><span class="line">chain.proceed(originalRequest);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下走<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,originalRequest, <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class="line"><span class="function"><span class="params">      RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        calls++; <span class="comment">// 后面 判断当前chain 只能调用一次</span></span><br><span class="line">     <span class="comment">// If we already have a stream, confirm that the incoming request will use it. </span></span><br><span class="line">     <span class="comment">//默认情况 this.httpCodec=null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed(). </span></span><br><span class="line">    <span class="comment">//默认情况 this.httpCodec=null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">          + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain. </span></span><br><span class="line">    <span class="comment">//执行下一次的interceptor</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + <span class="number">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码可知  <code>RealInterceptorChain</code> 通过递归调用 <code>okhttp3.Interceptor.Chain#proceed(request)</code> 有的同学会说 上面源码中 只调用了一次这个方法,在 <code>getResponseWithInterceptorChain</code> 没错，表面上只掉了一次，那他们怎么实现递归的？？？<br>答案在<code>interceptor.intercept(next);</code> 我们在实现一个Interceptor接口时,返回值是Response,我们必须调用 <code>Response okhttp3.Interceptor.Chain#proceed(request)</code> 才能得到Response<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">  Response intercept(Chain chain) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OkHttp源码分析-Interceptor&quot;&gt;&lt;a href=&quot;#OkHttp源码分析-Interceptor&quot; class=&quot;headerlink&quot; title=&quot;OkHttp源码分析 Interceptor&quot;&gt;&lt;/a&gt;OkHttp源码分析 Intercept
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析(二) Dispatcher</title>
    <link href="http://blog.zoudongq123.cn/2018/08/19/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://blog.zoudongq123.cn/2018/08/19/OkHttp源码分析(二)/</id>
    <published>2018-08-19T05:11:24.000Z</published>
    <updated>2019-03-16T09:23:48.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp源码分析-二-Dispatcher"><a href="#OkHttp源码分析-二-Dispatcher" class="headerlink" title="OkHttp源码分析(二) Dispatcher"></a>OkHttp源码分析(二) Dispatcher</h1><blockquote><p>okhttp发起请求的分发器</p></blockquote><h2 id="直接撸源码"><a href="#直接撸源码" class="headerlink" title="直接撸源码"></a>直接撸源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// okhttp3.OkHttpClient.Builder#dispatcher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">dispatcher</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (dispatcher == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"dispatcher == null"</span>);</span><br><span class="line">      <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//final 无法继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;   <span class="comment">//最大请求数量 ，可以单独设置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>; <span class="comment">//最大请求Host，可以单独设置</span></span><br><span class="line">数量</span><br><span class="line">  <span class="comment">// 以上是发出请求的两个限制 限制runningAsyncCalls 队列</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback; <span class="comment">//空闲时调用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService; <span class="comment">// 异步请求的线程池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// 正在执行异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">// 正在执行的同步队列</span></span><br><span class="line">   </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 okhttp3.Dispatcher 提供了两个构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Dispatcher 默认线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// 默认使用 无参构造   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//okhttp3.OkHttpClient.Builder#Builder() </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>知识点: ExecutorService 线程池相关学习</strong></p><h3 id="与发起请求的直接相关的方法："><a href="#与发起请求的直接相关的方法：" class="headerlink" title="与发起请求的直接相关的方法："></a>与发起请求的直接相关的方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步请求 调用</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步请求 调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题: 以上代码 两个 synchronized 同步的 有什么区别， 为什么这样写？？？</strong></p><p>由上面可见 同步和异步都加入相应的队列中，不同的是 异步会执行 <code>promoteAndExecute();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//以上是限制请求数量 ，下面开始加入 线程池中 等待执行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个返回值 在 okhttp3.Dispatcher#finished() 用到，如果 isRunning=false 就会调用  idleCallback.run()</span></span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们从 同步流程源码<a href="mweblib://15465027736165#execute`" target="_blank" rel="noopener">OkHttp 源码(一)  请求的大致流程</a> ，</p><p>异步流程源码<a href="mweblib://15465027736165#enqueue" target="_blank" rel="noopener">OkHttp 源码(一)  请求的大致流程</a></p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14re4ig7kj21860es7cx.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14rezuemsj218i0k0wql.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OkHttp源码分析-二-Dispatcher&quot;&gt;&lt;a href=&quot;#OkHttp源码分析-二-Dispatcher&quot; class=&quot;headerlink&quot; title=&quot;OkHttp源码分析(二) Dispatcher&quot;&gt;&lt;/a&gt;OkHttp源码分析(二) Di
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码分析(一)  请求的大致流程</title>
    <link href="http://blog.zoudongq123.cn/2018/08/14/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>http://blog.zoudongq123.cn/2018/08/14/OkHttp源码分析(一)/</id>
    <published>2018-08-14T09:15:25.000Z</published>
    <updated>2019-03-16T09:24:44.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp源码分析-一-请求的大致流程"><a href="#OkHttp源码分析-一-请求的大致流程" class="headerlink" title="OkHttp源码分析(一)  请求的大致流程"></a>OkHttp源码分析(一)  请求的大致流程</h1><blockquote><p>从使用用法开始入手</p></blockquote><h2 id="okhttp-拉取数据两种方式："><a href="#okhttp-拉取数据两种方式：" class="headerlink" title="okhttp 拉取数据两种方式："></a>okhttp 拉取数据两种方式：</h2><ul><li><p>同步执行（<strong><code>execute()</code></strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步获取</span></span><br><span class="line">val execute = OkHttpClient.Builder()</span><br><span class="line">                .build()</span><br><span class="line">                .newCall(Request.Builder()</span><br><span class="line">                .url(<span class="string">"http://www.baidu.com"</span>).build())</span><br><span class="line">                .execute();</span><br></pre></td></tr></table></figure></li><li><p>异步执行（<strong><code>enqueue(Callback)</code></strong>）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment">//异步获取</span></span><br><span class="line"> OkHttpClient.Builder().build()</span><br><span class="line">     .newCall(Request.Builder().url(<span class="string">"http://www.baidu.com"</span>).build())</span><br><span class="line">     .enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">                Log.e(<span class="string">"zoudong"</span>,<span class="string">"onFailure isExecuted=<span class="subst">$&#123;call.toString()&#125;</span> "</span>,e)</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                Log.e(<span class="string">"zoudong"</span>,<span class="string">"onResponse isExecuted=<span class="subst">$&#123;call.isExecuted&#125;</span> threed=<span class="subst">$&#123;Thread.currentThread().name&#125;</span> ,response=<span class="subst">$&#123;response.receivedResponseAtMillis() - response.sentRequestAtMillis()&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="开动"><a href="#开动" class="headerlink" title="开动"></a>开动</h2><p>一个请求发出我们需要准备两个对象  <code>OkHttpClient</code> , <code>Request</code></p><ol><li><h3 id="OkHttpClient装配一个Request"><a href="#OkHttpClient装配一个Request" class="headerlink" title="OkHttpClient装配一个Request"></a><code>OkHttpClient</code>装配一个<code>Request</code></h3></li></ol><p>   通过<code>OkHttpClient.newCall(Request)</code>来装配一个<code>Request</code></p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// okhttp3.OkHttpClient#newCall</span></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//okhttp3.RealCall#newRealCall</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">        RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">        call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//okhttp3.RealCall#RealCall</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">        <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">        <span class="keyword">this</span>.timeout = <span class="keyword">new</span> AsyncTimeout() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">timedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cancel();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li><h3 id="OkHttpClient-Call-执行"><a href="#OkHttpClient-Call-执行" class="headerlink" title="OkHttpClient.Call 执行"></a><code>OkHttpClient.Call 执行</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//okhttp3.Call</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">Call <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">      <span class="function">Call <span class="title">newCall</span><span class="params">(Request request)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>   Call真正的实现 okhttp3.RealCall， okhttpClient通过 newCall(request) 通过 okhttp3.RealCall#newRealCall包装request 后生成RealCall 通过 RealCall执行发出请求的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @startuml</span><br><span class="line"></span><br><span class="line"> OkHttpClient --&gt; Call: newCall(request)</span><br><span class="line"> Call -&gt;  RealCall: okhttp3.RealCall#newRealCall </span><br><span class="line"> Call --&gt; RealCall: Call真正的实现</span><br><span class="line"> Call -&gt; Response: Call.execute()</span><br><span class="line"> Call -&gt; Response: Call.enqueue(Callback)</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><h3 id="我们先看-okhttp3-RealCall-execute"><a href="#我们先看-okhttp3-RealCall-execute" class="headerlink" title="我们先看 okhttp3.RealCall#execute()"></a>我们先看 <code>okhttp3.RealCall#execute()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e = timeoutExit(e);</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>取出关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.dispatcher().executed(<span class="keyword">this</span>); <span class="comment">//加入同步队列</span></span><br><span class="line">Response result = getResponseWithInterceptorChain();<span class="comment">//生成 链式拦截器</span></span><br><span class="line">client.dispatcher().finished(<span class="keyword">this</span>);<span class="comment">//</span></span><br></pre></td></tr></table></figure></p><p>okhttp3.OkHttpClient#dispatcher 我们可以理解为 Call事件的分发器！ （暂时这里理解下次分析）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// promoteAndExecute 执行下一个异步Call</span></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">    <span class="comment">//isRunning 表示两个队列是否还有Call  isRunning=false 队列中无Call isRunning=true 对列表还有Call</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Runnable idleCallback okhttp3.Dispatcher#setIdleCallback</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>那问题来了Response怎么样返回的呢， 怎么样开始请求数据的呢？？？</p><p>仔细看的同学，应该很明显上面有三个关键方法， 我们只讲了两个方法，还有一个关键方法 <code>getResponseWithInterceptorChain()</code>  看这个方法的名字就知道 返回Response的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span></span><br><span class="line">  , <span class="number">0</span>,originalRequest, <span class="keyword">this</span>, eventListener,     client.connectTimeoutMillis(),</span><br><span class="line">     client.readTimeoutMillis(),client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>通过上面代码我们知道 <code>getResponseWithInterceptorChain</code>才是正真返回 <code>Response</code>的方法！<br> <strong>Interceptor</strong> 这个是重点 下期再来搞它</p><h3 id="我们再看-okhttp3-RealCall-enqueue"><a href="#我们再看-okhttp3-RealCall-enqueue" class="headerlink" title="我们再看 okhttp3.RealCall#enqueue()"></a>我们再看 <code>okhttp3.RealCall#enqueue()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步执行 <code>enqueue</code> 使用了 <code>AsyncCall(extends NamedRunnable)</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//okhttp3.Dispatcher#enqueue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call);  <span class="comment">//异步队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//遍历查找可执行的异步Call ,并且执行异步调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove();</span><br><span class="line">        executableCalls.add(asyncCall);</span><br><span class="line">        runningAsyncCalls.add(asyncCall);</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//执行AsyncCall开始执行异步操作</span></span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过readyAsyncCalls 遍历和过滤生成可以执行队列 <code>runningAsyncCalls</code>队列和 <code>executableCalls</code>队列。</p><p>readyAsyncCalls 生成 executableCalls 有两个限制条件，请求Call 必须小于maxRequests（64），host小于maxRequestsPerHost（5）</p><p>executableCalls 遍历执行 <code>asyncCall.executeOn(executorService());</code>而 <code>executorService()</code>返回的是一个线程池。</p><p>继续跟进  我们知道  AsyncCall是一个<code>implements Runnable</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  okhttp3.Dispatcher#promoteAndExecute 调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">executeOn</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">      <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 调用Runnable#run方法</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        InterruptedIOException ioException = <span class="keyword">new</span> InterruptedIOException(<span class="string">"executor rejected"</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        eventListener.callFailed(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, ioException);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="keyword">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run方法包装的 execute()</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      timeout.enter();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e = timeoutExit(e);</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          eventListener.callFailed(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常执行 也有几个关键方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">Response response = getResponseWithInterceptorChain();</span><br><span class="line">client.dispatcher().finished(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>OkHttpClient 同步获取和异步获取<code>Response</code> 大致的不同到这里大致有所了解了吧！<br><strong>想必大家对 Dispatcher 和  Interceptor 有很大的疑问？？？</strong></p><blockquote><p>这两块内容过多， 下次分析</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14rfyni4sj216s1dk7wh.jpg" alt=""></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> 同步和异步调用大致流程一致，同步请求 通过<code>getResponseWithInterceptorChain()</code>直接返回 <code>Response</code> 异步方法 通过线程池方式调用<code>getResponseWithInterceptorChain()</code>直接返回 <code>Response</code></p><p> 注意：<code>enqueue(Callback)</code> 的 <code>Callback</code>回调是在线程(Okhttp)中执行的 ，并不是主线程(main)</p><h2 id="下期内容"><a href="#下期内容" class="headerlink" title="下期内容"></a>下期内容</h2><p> OkHttp源码 之 Dispatcher<br> OkHttp源码 之 Interceptor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OkHttp源码分析-一-请求的大致流程&quot;&gt;&lt;a href=&quot;#OkHttp源码分析-一-请求的大致流程&quot; class=&quot;headerlink&quot; title=&quot;OkHttp源码分析(一)  请求的大致流程&quot;&gt;&lt;/a&gt;OkHttp源码分析(一)  请求的大致流程&lt;/
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="源码解析" scheme="http://blog.zoudongq123.cn/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative基础之Text</title>
    <link href="http://blog.zoudongq123.cn/2018/06/08/ReactNative%E5%9F%BA%E7%A1%80%E4%B9%8BText/"/>
    <id>http://blog.zoudongq123.cn/2018/06/08/ReactNative基础之Text/</id>
    <published>2018-06-08T07:40:19.000Z</published>
    <updated>2019-03-16T09:30:49.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactNative基础之Text"><a href="#ReactNative基础之Text" class="headerlink" title="ReactNative基础之Text"></a>ReactNative基础之Text</h1><blockquote><p>Text 只是一个显示文本控件， 继承于View</p></blockquote><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><blockquote><p> <a href="https://reactnative.cn/docs/view-style-props/" target="_blank" rel="noopener">样式（style）和属性(props)</a>  这些就不说了 用到就查文档</p></blockquote><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><blockquote><p>除了上面的样式和属性之外 还有一个控件的特殊属性 </p></blockquote><h4 id="Style样式"><a href="#Style样式" class="headerlink" title="Style样式"></a>Style样式</h4><ul><li><p>textShadowOffset: object: {width: number,height: number}</p></li><li><p>color: color    //字体颜色</p></li><li><p>fontSize: number  //字体大小</p></li><li><p>fontStyle: enum(‘normal’, ‘italic’) //字体样式</p></li><li><p>fontWeight: enum(‘normal’, ‘bold’, ‘100’, ‘200’, ‘300’, ‘400’, ‘500’, ‘600’, ‘700’, ‘800’, ‘900’) //字体粗细<br>  指定字体的粗细。大多数字体都支持’normal’和’bold’值。并非所有字体都支持所有的数字值。如果某个值不支持，则会自动选择最接近的值。</p></li><li><p>lineHeight: number</p></li><li><p>textAlign: enum(‘auto’, ‘left’, ‘right’, ‘center’, ‘justify’)</p><pre><code>指定文本的对齐方式。其中&apos;justify&apos;值仅iOS支持，在Android上会变为left。</code></pre></li><li><p>textDecorationLine: enum(‘none’, ‘underline’, ‘line-through’, ‘underline line-through’)</p></li><li><p>textShadowColor: color</p></li><li><p>fontFamily: string</p></li><li><p>textShadowRadius: number</p></li><li><p>includeFontPadding: bool (Android)<br>  Android在默认情况下会为文字额外保留一些padding，以便留出空间摆放上标或是下标的文字。对于某些字体来说，这些额外的padding可能会导致文字难以垂直居中。如果你把textAlignVertical设置为center之后，文字看起来依然不在正中间，那么可以尝试将本属性设置为false。默认值为true。</p></li></ul><h4 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h4><ul><li><p>allowFontScaling    控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。</p></li><li><p>onLongPress    这个Text 特有 点击事件，其他View 需要点击事件需要Touch* 控件包裹着</p></li><li><p>onPress        这个Text 特有 点击事件  需要点击事件需要Touch* 控件包裹着</p></li><li><p>adjustsFontSizeToFit  <code>iOS特有</code>  指定字体是否随着给定样式的限制而自动缩放。</p></li></ul><h4 id="上手操作"><a href="#上手操作" class="headerlink" title="上手操作"></a>上手操作</h4><p>我们来修改创建的AwesomeProject 程序的入口App.js 功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Platform, StyleSheet, Text, View&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instructions = Platform.select(&#123;</span><br><span class="line">  ios: <span class="string">'Press Cmd+R to reload,\n'</span> + <span class="string">'Cmd+D or shake for dev menu'</span>,</span><br><span class="line">  android:</span><br><span class="line">    <span class="string">'Double tap R on your keyboard to reload,\n'</span> +</span><br><span class="line">    <span class="string">'Shake or press menu button for dev menu'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">//2.组件的渲染 render()方法 必须返回 View / null;</span></span><br><span class="line">  render() &#123;</span><br><span class="line"><span class="comment">//3.组件渲染返回的View ,只有返回View才能显示出来</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line"><span class="comment">//4. style样式</span></span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;To get started, edit App.js&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Text style=&#123;styles.instructions&#125;&gt;&#123;instructions&#125;&lt;/</span>Text&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const styles = StyleSheet.create(&#123;</span></span><br><span class="line"><span class="regexp">  container: &#123;</span></span><br><span class="line"><span class="regexp">    flex: 1,</span></span><br><span class="line"><span class="regexp">    justifyContent: 'center',</span></span><br><span class="line"><span class="regexp">    alignItems: 'center',</span></span><br><span class="line"><span class="regexp">    backgroundColor: '#F5FCFF',</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  welcome: &#123;</span></span><br><span class="line"><span class="regexp">    fontSize: 20,</span></span><br><span class="line"><span class="regexp">    textAlign: 'center',</span></span><br><span class="line"><span class="regexp">    margin: 10,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  instructions: &#123;</span></span><br><span class="line"><span class="regexp">    textAlign: 'center',</span></span><br><span class="line"><span class="regexp">    color: '#333333',</span></span><br><span class="line"><span class="regexp">    marginBottom: 5,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style=&#123;style&#125; &#123;<span class="keyword">this</span>.props&#125;&gt; &lt;/Text&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌套文本"><a href="#嵌套文本" class="headerlink" title="嵌套文本"></a>嵌套文本</h4><p>下面介绍 Text的特殊用法</p><blockquote><p>在iOS和Android中显示格式化文本的方法类似，都是提供你想显示的文本内容，然后使用范围标注来指定一些格式（在iOS上是用NSAttributedString，Android上则是SpannableString）。这种用法非常繁琐。在React Native中，我们决定采用和Web一致的设计，这样你可以把相同格式的文本嵌套包裹起来：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to </span><br><span class="line">     &lt;Text style=&#123;styles.welcome&#125;&gt; React Native!&lt;/Text&gt;</span><br><span class="line">&lt;<span class="regexp">/Text&gt;</span></span><br></pre></td></tr></table></figure><h4 id="嵌套视图（仅限iOS）"><a href="#嵌套视图（仅限iOS）" class="headerlink" title="嵌套视图（仅限iOS）"></a>嵌套视图（仅限iOS）</h4><ul><li>Android<br>没错， 就是Text 嵌套 Text 但是不能嵌套View 否则报错 <code>Invariant Violation:Nesting of &lt;Text&gt; is not currently supported</code><br><img src="media/15450566409131/15452028957866.jpg" alt=""></li></ul><p>还有一个小知识点 <code>Text</code> 使用表达式 需要<code>{ 表达式 }</code> 包括换行符: {‘我要换行\n’} </p><ul><li><p>iOS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">      There is a blue square</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">width</span>: <span class="number">50</span>, <span class="attr">height</span>: <span class="number">50</span>, <span class="attr">backgroundColor</span>: <span class="string">'steelblue'</span>&#125;&#125; /&gt;</span><br><span class="line">      <span class="keyword">in</span> between my text.</span><br><span class="line">    &lt;<span class="regexp">/Text&gt;</span></span><br></pre></td></tr></table></figure><p><img src="media/15450566409131/15452033622860.jpg" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactNative基础之Text&quot;&gt;&lt;a href=&quot;#ReactNative基础之Text&quot; class=&quot;headerlink&quot; title=&quot;ReactNative基础之Text&quot;&gt;&lt;/a&gt;ReactNative基础之Text&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative基础之flexbox布局</title>
    <link href="http://blog.zoudongq123.cn/2018/06/07/ReactNative%E5%9F%BA%E7%A1%80%E4%B9%8BFlexBox/"/>
    <id>http://blog.zoudongq123.cn/2018/06/07/ReactNative基础之FlexBox/</id>
    <published>2018-06-07T06:27:19.000Z</published>
    <updated>2019-03-16T09:16:38.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactNative基础之FlexBox"><a href="#ReactNative基础之FlexBox" class="headerlink" title="ReactNative基础之FlexBox"></a>ReactNative基础之FlexBox</h1><h2 id="什么是Flexbox布局（“弹性布局”）"><a href="#什么是Flexbox布局（“弹性布局”）" class="headerlink" title="什么是Flexbox布局（“弹性布局”）"></a>什么是Flexbox布局（“弹性布局”）</h2><blockquote><p>React中引入了flexbox概念,flexbox是属于web前端领域CSS的一种布局方案，是2009年W3C提出了一种新的布局方案，可以简便、完整、响应式地实现各种页面布局。你可以简单的理解为flexbox是CSS领域类似Android中 <code>LinearLayout</code>的一种布局，但是要比 <code>LinearLayout</code>要强大的多!</p></blockquote><h2 id="flexbox布局的组成"><a href="#flexbox布局的组成" class="headerlink" title="flexbox布局的组成"></a>flexbox布局的组成</h2><ol><li>首先使用Flexbox需要理解两个概念： 主轴（main axis）和侧轴（cross axis）主轴和侧轴是互相垂直的，在<code>react-native</code>中 主轴是<strong>垂直方向</strong>，</li><li>flexbox 布局由<strong>伸缩容器</strong>和<strong>伸缩项目</strong>组成。任何一个元素都可以指定为 flexbox 布局。</li><li>伸缩容器的子元素称为伸缩项目。</li></ol><h2 id="伸缩容器的相关属性说明"><a href="#伸缩容器的相关属性说明" class="headerlink" title="伸缩容器的相关属性说明"></a>伸缩容器的相关属性说明</h2><h3 id="flexDirection-控制主轴方向"><a href="#flexDirection-控制主轴方向" class="headerlink" title="flexDirection  控制主轴方向"></a><code>flexDirection</code>  控制主轴方向</h3><blockquote><p><strong>row</strong>(水平方向) | <strong>column</strong>(垂直方向)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flexDirection: <span class="string">'column'</span>  <span class="comment">//row | column(react-native默认）</span></span><br></pre></td></tr></table></figure><center><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqag854j20h60eadfu.jpg" width="40%" height="40%"><br><br>flexDirection_column<br></center><center><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqadbo8j20iu0d2aa2.jpg" width="40%" height="40%"><br><br>flexDirection_row<br></center><h3 id="justifyContent-伸缩项目在伸缩容器的主轴方向对齐方式"><a href="#justifyContent-伸缩项目在伸缩容器的主轴方向对齐方式" class="headerlink" title="justifyContent 伸缩项目在伸缩容器的主轴方向对齐方式"></a><code>justifyContent</code> 伸缩项目在伸缩容器的主轴方向对齐方式</h3><blockquote><p>flex-start、center、flex-end、space-around、space-between</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justifyContent: <span class="string">'flex-start'</span>   <span class="comment">//默认方式</span></span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>（默认值）：伸缩项目向主轴线的起始位置靠齐。</li><li><code>center</code> ：  伸缩项目向主轴线的中间位置靠齐。</li><li><code>flex-end</code> ：伸缩项目向主轴线的结束位置靠齐。</li><li><code>space-between</code> ：伸缩项目会平均地分布在主轴线里。第一个项目在主轴线开始位置，最后一个项目在终点位置。</li><li><code>space-around</code> ：伸缩项目会平均地分布在主轴线里，两端保留一半的空间。</li></ul><p><code>space-around</code> 表示单个<strong>元素左右</strong>的间距 注意对比<code>space-between</code></p><p><code>space-between</code>表示两个<strong>元素之间</strong>的间距 注意对比<code>space-around</code></p><center><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqangrnj20hw0sowep.jpg" width="40%" height="40%"><br><br>justifyContent_flex_center<br><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqajwddj20iu0tyglv.jpg" width="40%" height="40%"><br><br>justifyContent_flex_end<br><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqavme6j20gw0qyt8w.jpg" width="40%" height="40%"><br><br>justifyContent_space_between<br><br><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqas92tj20he0rsq35.jpg" width="40%" height="40%"><br><br>justifyContent_space-around<br><br></center><h3 id="alignItems-伸缩项目在伸缩容器的侧轴上的对齐方式"><a href="#alignItems-伸缩项目在伸缩容器的侧轴上的对齐方式" class="headerlink" title="alignItems 伸缩项目在伸缩容器的侧轴上的对齐方式"></a><span id="jump_alignItems"><code>alignItems</code></span> 伸缩项目在伸缩容器的侧轴上的对齐方式</h3><blockquote><p>flex-start、center、flex-end、stretch</p></blockquote><ul><li><code>flex-start</code>(默认值)：伸缩项目向侧轴的起始位置靠齐。</li><li><code>flex-end</code>：伸缩项目向侧轴的结束位置靠齐。</li><li><code>center</code>：伸缩项目向侧轴的中间位置靠齐。</li><li><code>stretch</code>（默认值）：伸缩项目在<code>侧轴方向</code>拉伸填充整个伸缩容器。<br>注意：这种情况下项目不能设置高度，否则看不到效果。</li></ul><center><br><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqa94vxj20h00r2wen.jpg" width="40%" height="40%"><br><br>alignItems_flex-end<br><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqb6kjvj20h60hymyd.jpg" width="40%" height="40%"><br><br>alignItems_stretch<br></center><h3 id="flexWrap-伸缩项目在伸缩容器的主轴上显示不下的对齐方式"><a href="#flexWrap-伸缩项目在伸缩容器的主轴上显示不下的对齐方式" class="headerlink" title="flexWrap 伸缩项目在伸缩容器的主轴上显示不下的对齐方式"></a><code>flexWrap</code> 伸缩项目在伸缩容器的主轴上显示不下的对齐方式</h3><blockquote><p>nowrap | wrap   nowrap 不换行  ， wrap换行</p></blockquote><h3 id="flex-伸缩项目的放大比例"><a href="#flex-伸缩项目的放大比例" class="headerlink" title="flex 伸缩项目的放大比例"></a><code>flex</code> 伸缩项目的放大比例</h3><blockquote><p>默认值是 0，即表示如果存在剩余空间，也不放大。<br>如果将所有的伸缩项目的 <code>flex</code> 设置为 1，那么每个伸缩项目将设置为一个大小相等的剩余空间。<br>如果又将其中一个伸缩项目的 <code>flex</code> 设置为 2，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占的剩余空间的两倍。</p></blockquote><p>宽度 ＝ 弹性宽度 * ( flexGrow / sum( flexGorw ) )</p><h3 id="alignSelf-设置单独的伸缩项目在侧轴上的对齐方式，会覆盖默认的对齐方式"><a href="#alignSelf-设置单独的伸缩项目在侧轴上的对齐方式，会覆盖默认的对齐方式" class="headerlink" title="alignSelf 设置单独的伸缩项目在侧轴上的对齐方式，会覆盖默认的对齐方式"></a><code>alignSelf</code> 设置单独的伸缩项目在侧轴上的对齐方式，会覆盖默认的对齐方式</h3><blockquote><p>auto、flex-start、flex-end、center、stretch。</p></blockquote><p><strong>使用场景：</strong> 伸缩容器中设置了 <a href="#jump_alignItems"><strong>alignItems</strong></a> 对齐方式 ，<code>alignSelf</code>设置单个伸缩项目单独的对齐方式</p><center><br><img src="https://ws1.sinaimg.cn/large/882b6a2aly1g14qqb12ntj20h00mgt9f.jpg" width="40%" height="40%"><br><br>alignSeft_flex-end<br></center><hr><p>参考：</p><p>官方： <a href="https://reactnative.cn/docs/flexbox/" target="_blank" rel="noopener">可以在线编写布局直接看效果，但是需要翻墙</a></p><p>第三方：<a href="https://www.jianshu.com/p/2acddb3731a7" target="_blank" rel="noopener">从零学React Native之flexbox布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactNative基础之FlexBox&quot;&gt;&lt;a href=&quot;#ReactNative基础之FlexBox&quot; class=&quot;headerlink&quot; title=&quot;ReactNative基础之FlexBox&quot;&gt;&lt;/a&gt;ReactNative基础之FlexBox&lt;/
      
    
    </summary>
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative基础之State和Props</title>
    <link href="http://blog.zoudongq123.cn/2018/06/06/ReactNative%E5%9F%BA%E7%A1%80%E4%B9%8BState%E5%92%8CProps/"/>
    <id>http://blog.zoudongq123.cn/2018/06/06/ReactNative基础之State和Props/</id>
    <published>2018-06-06T06:27:19.000Z</published>
    <updated>2019-03-16T09:31:04.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReactNative基础之State和Props"><a href="#ReactNative基础之State和Props" class="headerlink" title="ReactNative基础之State和Props"></a>ReactNative基础之State和Props</h1><blockquote><p>React Native 看起来很像 React，只不过其基础组件是原生组件而非 web 组件。要理解 React Native 应用的基本结构，首先需要了解一些基本的 React 的概念，比如 <a href="http://www.cnblogs.com/zourong/p/6043914.html" target="_blank" rel="noopener">JSX 语法</a>、组件、state状态以及props属性。如果你已经了解了 React，那么还需要掌握一些 React Native 特有的知识，比如原生组件的使用。这篇教程可以供任何基础的读者学习，不管你是否有 React 方面的经验。</p></blockquote><p><code>在任何应用中，数据都是必不可少的。我们需要直接的改变页面上一块的区域来使得视图的刷新，或者间接地改变其他地方的数据。React的数据是自顶向下单向流动的，即从父组件到子组件中，组件的数据存储在props和state中，这两个属性有啥子区别呢？</code></p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件。</p><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据。由于React是<code>单向数据流</code>，所以props基本上也就是从父级组件向子组件传递的数据。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设我们现在需要实现一个列表，根据React组件化思想，我们可以把列表中的行当做一个组件，也就是有这样两个组件：<itemlist>和<item>。</item></itemlist></p><p><strong>父控件 <itemlist></itemlist></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">"./item"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">     <span class="keyword">const</span> itemList = data.map(<span class="function"><span class="params">item</span> =&gt;</span> &lt;Item item=item /&gt;);</span><br><span class="line">     render()&#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">         &#123;itemList&#125;</span><br><span class="line">       )</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>列表的数据我们就暂时先假设是放在一个data变量中，然后通过map函数返回一个每一项都是<item item="数据">的数组，也就是说这里其实包含了data.length个<item>组件，数据通过在组件上自定义一个参数传递。当然，这里想传递几个自定义参数都可以。</item></item></p><p><strong>子控件 <item></item></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;&#123;<span class="keyword">this</span>.props.item&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>在render函数中可以看出，组件内部是使用this.props来获取传递到该组件的所有数据，它是一个对象，包含了所有你对这个组件的配置，现在只包含了一个item属性，所以通过this.props.item来获取即可。</p><h4 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h4><blockquote><p>props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是<code>只读的，不可改变的</code>。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。<br>比如，这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义默认参数</span></span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  item: <span class="string">'Hello Props'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义Props类型</span></span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  item: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>关于propTypes，可以声明为以下几种类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">optionalArray:  PropTypes.array,</span><br><span class="line">optionalBool:   PropTypes.bool,</span><br><span class="line">optionalFunc:   PropTypes.func,</span><br><span class="line">optionalNumber: PropTypes.number,</span><br><span class="line">optionalObject: PropTypes.object,</span><br><span class="line">optionalString: PropTypes.string,</span><br><span class="line">optionalSymbol: PropTypes.symbol,</span><br></pre></td></tr></table></figure><p>官方文档： <a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://facebook.github.io/react/docs/typechecking-with-proptypes.html</a></p><p><code>总结：</code>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><blockquote><p>State is similar to props, but it is private and fully controlled by the component.<br>一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。</p></blockquote><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化 state 有两种方式</span></span><br><span class="line">  <span class="comment">// state = &#123;</span></span><br><span class="line"> <span class="comment">//    itemList:'一些数据',</span></span><br><span class="line"> <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      itemList:<span class="string">'一些数据'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.itemList&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在组件初始化的时候，通过this.state给组件必须设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。</p><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><code>state</code>不同于<code>props</code>的一点是，state是可以被改变的。不过，不可以直接通过this.state=的方式来修改，而需要通过this.setState()方法来修改state。</p><p>比如，我们经常会通过异步操作来获取数据，我们需要在<code>componentDidMount</code>阶段来执行异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">  fetch(<span class="string">'url'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">itemList</span>:item&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据获取完成后，通过<code>this.setState</code>来修改数据状态。</p><p>当我们调用<code>this.setState</code>方法时，React会更新组件的数据状态state，并且重新调用<code>render</code>方法，也就是会对组件进行重新渲染。</p><p>注意：通过this.state=来初始化state，使用<code>this.setState</code>来修改state，constructor是唯一能够初始化的地方。</p><p>setState接受一个对象或者函数作为第一个参数，只需要传入需要更新的部分即可，不需要传入整个对象，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">//上面说过 有两种方式初始化 state </span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'老黄'</span>,</span><br><span class="line">      age: <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完<code>setState</code>之后的state应该是{name:’老黄’,age:18}。</p><p>setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  name:<span class="string">'被修改了'</span></span><br><span class="line">&#125;,()=&gt;<span class="built_in">console</span>.log(<span class="string">'setState finished'</span>))</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><p><code>state</code>是组件自己管理数据，控制自己的状态，可变；<br><code>props</code>是外部传入的数据参数，不可变；<br>没有<code>state</code>的叫做<code>无状态组件</code>，有<code>state</code>的叫做<code>有状态组件</code>；<br>多用props，少用state。也就是多写无状态组件。</p><p><strong>PS : componentDidMount在React 16时候 已经被废弃了, <a href="https://segmentfault.com/a/1190000014456811?utm_source=channel-hottest" target="_blank" rel="noopener">新生命周期</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReactNative基础之State和Props&quot;&gt;&lt;a href=&quot;#ReactNative基础之State和Props&quot; class=&quot;headerlink&quot; title=&quot;ReactNative基础之State和Props&quot;&gt;&lt;/a&gt;ReactNative
      
    
    </summary>
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/categories/react-native/"/>
    
    
      <category term="react-native" scheme="http://blog.zoudongq123.cn/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>基于IJKPlayer视频播放器简单封装设计</title>
    <link href="http://blog.zoudongq123.cn/2018/05/02/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://blog.zoudongq123.cn/2018/05/02/视频播放器设计/</id>
    <published>2018-05-02T02:37:05.000Z</published>
    <updated>2019-03-16T07:58:47.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="播放器的简单设计"><a href="#播放器的简单设计" class="headerlink" title="播放器的简单设计"></a>播放器的简单设计</h2><p>播放器基于IJKPlayer来设计的， 播放器大致分三层  </p><blockquote><p> 1.播放内核（基于ijkMediaplayer）<br>2.播放器View<br>3.播放器的MediaController</p></blockquote><h4 id="1、封装播放内核"><a href="#1、封装播放内核" class="headerlink" title="1、封装播放内核"></a>1、封装播放内核</h4><blockquote><p>我们都知道需要播放一个视频需要三个过程 1.create MediaPlayer   2.MediaPlayer prepare  3.MediaPlayer 与 Surface 绑定<br>xinvideoplayer中使用了VideoManager来控制ijkmediaplayer 所有的操作</p></blockquote><p>三个过程 我们使用 HandlerThread + Hander 来实现   第一个过程创建大致可能需要100ms左右，严重影响UI线程！！！</p><ul><li>第一个过程：  create MediaPlayer <blockquote><p>new IjkMediaPlayer() 设置一些播放器回调方法</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IJK 的 Mediaplayer api 类似 Android 系统播放器api</span></span><br><span class="line"><span class="comment">//IMediaPlayer.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnPreparedListener</span><span class="params">(IMediaPlayer.OnPreparedListener var1)</span></span>;  <span class="comment">//prepareAsync 之后回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnCompletionListener</span><span class="params">(IMediaPlayer.OnCompletionListener var1)</span></span>; <span class="comment">//播放完成回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnBufferingUpdateListener</span><span class="params">(IMediaPlayer.OnBufferingUpdateListener var1)</span></span>;<span class="comment">//当播放网络的数据流的buffer发生变化的时候</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnSeekCompleteListener</span><span class="params">(IMediaPlayer.OnSeekCompleteListener var1)</span></span>;<span class="comment">//当seek定位操作完成后</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnVideoSizeChangedListener</span><span class="params">(IMediaPlayer.OnVideoSizeChangedListener var1)</span></span>;<span class="comment">//当视频的大小第一次被知道或者发生改变时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnErrorListener</span><span class="params">(IMediaPlayer.OnErrorListener var1)</span></span>;<span class="comment">//当有发生错误</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnInfoListener</span><span class="params">(IMediaPlayer.OnInfoListener var1)</span></span>;<span class="comment">//当有信息或者警告</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnTimedTextListener</span><span class="params">(IMediaPlayer.OnTimedTextListener var1)</span></span>; <span class="comment">//当媒体的时间数据需要被显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二个阶段 prepare<blockquote><p>mediaPlayer.prepareAsync();  等待回调 IMediaPlayer.OnPreparedListener#onPrepare()</p></blockquote></li></ul><ul><li>第三个阶段 给IJKMediaPlayer 绑定 Surface 呈现画面<blockquote><p>mediaPlayer.setSurface();</p></blockquote></li></ul><h4 id="2、播放器View"><a href="#2、播放器View" class="headerlink" title="2、播放器View"></a>2、播放器View</h4><blockquote><p>实现 播放器基本方法（IViewPlayer）和 播放内核回调方法（IMediaPlayerListener）<br>IMediaPlayerListener 是包装 <a href="https://github.com/Bilibili/ijkplayer/blob/master/android/ijkplayer/ijkplayer-java/src/main/java/tv/danmaku/ijk/media/player/IMediaPlayer.java" target="_blank" rel="noopener">IMediaPlayer</a> 所有接口并通过 Handle 发送到主线程中实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IVideoPlayer.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IVideoPlayer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//开始播放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;<span class="comment">//暂停播放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seekTo</span><span class="params">(<span class="keyword">long</span> time)</span></span>; <span class="comment">//seekto time  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;<span class="comment">//关闭播放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVideoPath</span><span class="params">()</span></span>;<span class="comment">//设置视频路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStartFullScreen</span><span class="params">()</span></span>;<span class="comment">//全屏播放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBackFullScreen</span><span class="params">()</span></span>; <span class="comment">//退出全屏</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResumeVideo</span><span class="params">()</span></span>;<span class="comment">//播放器后台唤起</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPauseVideo</span><span class="params">()</span></span>;<span class="comment">//切换后台</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentState</span><span class="params">()</span></span>;<span class="comment">//视频的当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrentScreenState</span><span class="params">()</span></span>; <span class="comment">//当前屏幕的状态  例如小屏，大屏，竖屏</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getTcpSpeed</span><span class="params">()</span></span>;<span class="comment">//获取网速</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchVideoSource</span><span class="params">(String url,<span class="keyword">long</span> delay)</span></span>;<span class="comment">//切换清晰度 并流畅的切换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayerListener</span> <span class="keyword">extends</span> <span class="title">IVideoPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onAutoCompletion</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBufferingUpdate</span><span class="params">(<span class="keyword">int</span> percent)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSeekComplete</span><span class="params">(<span class="keyword">long</span> currentPosition)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInfo</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onVideoSizeChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上接口大致满足了所有播放器的功能要求！！</p><h4 id="3-MediaController"><a href="#3-MediaController" class="headerlink" title="3.MediaController"></a>3.MediaController</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVideoController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//顾名思义</span></span><br><span class="line">   <span class="function">View <span class="title">bindPlayer</span><span class="params">(IVideoPlayer player)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onChangeVideoStatus</span><span class="params">(IVideoPlayer player, <span class="keyword">int</span> old_status, <span class="keyword">int</span> new_status)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onChangeScreenStatus</span><span class="params">(IVideoPlayer player, <span class="keyword">int</span> old_status, <span class="keyword">int</span> new_status)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">onChangedNetWork</span><span class="params">(<span class="keyword">int</span> currentNetState)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onVideoProgress</span><span class="params">(<span class="keyword">int</span> percent, <span class="keyword">long</span> curr_position, <span class="keyword">long</span> duration)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">unbindPlayer</span><span class="params">(IVideoPlayer player)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLock</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onVideoDefinitionSwitched</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isShowing</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>  BaseVideoPlayer#setVideoController()</p><ul><li>播放器的简单接入使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">videoplayer.setVideoPath(url);</span><br><span class="line">videoplayer.start();<span class="comment">//开始播放</span></span><br><span class="line"><span class="comment">//如果需要后台暂停唤起继续播放</span></span><br><span class="line">videoplayer.onVideoResume();</span><br><span class="line">videoplayer.onVideoPause();</span><br><span class="line"><span class="comment">//如果需要后台暂停唤起继续播放</span></span><br><span class="line">全屏时控制返回键问题：</span><br><span class="line"><span class="keyword">if</span> (!VideoPlayerUtils.onBackPressed()) &#123;</span><br><span class="line">    <span class="comment">//返回的正常逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="播放器的内部实现"><a href="#播放器的内部实现" class="headerlink" title="播放器的内部实现"></a>播放器的内部实现</h2><p><img src="http://ow9n8vqns.bkt.clouddn.com/VideoPlayer%20%E6%92%AD%E6%94%BE.png" alt="start"></p><h4 id="预加载需求-amp-复用播放器"><a href="#预加载需求-amp-复用播放器" class="headerlink" title="预加载需求 &amp; 复用播放器"></a>预加载需求 &amp; 复用播放器</h4><p><img src="http://ow9n8vqns.bkt.clouddn.com/%E5%A4%8D%E7%94%A8%E6%92%AD%E6%94%BE%E5%99%A8&amp;%E9%A2%84%E5%8A%A0%E8%BD%BD.png" alt="预加载"></p><h4 id="智能后台-amp-唤起处理"><a href="#智能后台-amp-唤起处理" class="headerlink" title="智能后台&amp;唤起处理"></a>智能后台&amp;唤起处理</h4><p><img src="http://ow9n8vqns.bkt.clouddn.com/onVideoResume&amp;onVideoPause.png" alt="智能后台&amp;唤起处理"></p><h2 id="播放器的扩展实现"><a href="#播放器的扩展实现" class="headerlink" title="播放器的扩展实现"></a>播放器的扩展实现</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;播放器的简单设计&quot;&gt;&lt;a href=&quot;#播放器的简单设计&quot; class=&quot;headerlink&quot; title=&quot;播放器的简单设计&quot;&gt;&lt;/a&gt;播放器的简单设计&lt;/h2&gt;&lt;p&gt;播放器基于IJKPlayer来设计的， 播放器大致分三层  &lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="ijkplayer" scheme="http://blog.zoudongq123.cn/tags/ijkplayer/"/>
    
  </entry>
  
  <entry>
    <title>Activtiy加载时间调研</title>
    <link href="http://blog.zoudongq123.cn/2018/04/10/Activtiy%E5%8A%A0%E8%BD%BD%E6%97%B6%E9%97%B4/"/>
    <id>http://blog.zoudongq123.cn/2018/04/10/Activtiy加载时间/</id>
    <published>2018-04-10T09:22:12.000Z</published>
    <updated>2019-03-16T07:58:47.498Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义</p><blockquote><p>个人理解，进入Activity开始一直到首屏页面被渲染出来（用户可见状态）这个时间差不多就是Activity的加载时间！</p></blockquote><h3 id="方案一、onCreate-onResume-的时间差"><a href="#方案一、onCreate-onResume-的时间差" class="headerlink" title="方案一、onCreate(),onResume()的时间差"></a>方案一、onCreate(),onResume()的时间差</h3><p>首先脑海里弄出来的方案就是分别在onCreate(),onResume() 统计时间计算时间差，<br>查看源码发现 Activity#onResume()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called after &#123;<span class="doctag">@link</span> #onRestoreInstanceState&#125;, &#123;<span class="doctag">@link</span> #onRestart&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onPause&#125;, for your activity to start interacting with the user.</span></span><br><span class="line"><span class="comment">     * This is a good place to begin animations, open exclusive-access devices</span></span><br><span class="line"><span class="comment">     * (such as the camera), etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Keep in mind that onResume is not the best indicator that your activity</span></span><br><span class="line"><span class="comment">     * is visible to the user; a system window such as the keyguard may be in</span></span><br><span class="line"><span class="comment">     * front.  Use &#123;<span class="doctag">@link</span> #onWindowFocusChanged&#125; to know for certain that your</span></span><br><span class="line"><span class="comment">     * activity is visible to the user (for example, to resume a game).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;em&gt;Derived classes must call through to the super class's</span></span><br><span class="line"><span class="comment">     * implementation of this method.  If they do not, an exception will be</span></span><br><span class="line"><span class="comment">     * thrown.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #onRestoreInstanceState</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #onRestart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #onPostResume</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #onPause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onResume "</span> + <span class="keyword">this</span>);</span><br><span class="line">        getApplication().dispatchActivityResumed(<span class="keyword">this</span>);</span><br><span class="line">        mActivityTransitionState.onResume();</span><br><span class="line">        mCalled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>onResume() 用户可交互的状态，显然作为用户可见的状态 activity加载时间有误差较大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.app.ActivityThread#handleResumeActivity</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">        <span class="comment">//内部调用了   r.activity.performResume();</span></span><br><span class="line">        ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">/** wm对象其实是 WindowManager（WindowManagerImpl） </span></span><br><span class="line"><span class="comment">        在android.view.Window#setWindowManager(android.view.WindowManager, android.os.IBinder, java.lang.String, boolean) 创建</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">         ...</span><br><span class="line">         </span><br><span class="line">            <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">            cleanUpPendingRemoveWindows(r);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">            <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Resuming activity "</span></span><br><span class="line">                            + r.activityInfo.name + <span class="string">" with newConfig "</span> + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Resuming "</span> + r + <span class="string">" with isForward="</span></span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        != forwardBit) &#123;</span><br><span class="line">                    l.softInputMode = (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm = a.getWindowManager();</span><br><span class="line">                        View decor = r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>performResumeActivity 之后才开始正真的绘制界面   wm.addView(decor, l);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleResumeActivity()</span><br><span class="line">  --- performResumeActivity()</span><br><span class="line">      --- r.activity.performResume();</span><br><span class="line">          --- onResume()</span><br><span class="line">  ---<span class="function">add <span class="title">DecorView</span>   <span class="params">(wm.addView(decor, l)</span></span>;)</span><br><span class="line">  ---wm.updateViewLayout(decor, l);</span><br><span class="line">     --- scheduleTraversals</span><br><span class="line">          ---  performDraw（）， performMeasure（） ， performLayout（）</span><br></pre></td></tr></table></figure></p><p>onResume() 之后才开始 绘制布局<br>上面代码更加证明了onResume()不能计算结束加载时间标志 </p><h3 id="方案二、onWindowFocusChanged"><a href="#方案二、onWindowFocusChanged" class="headerlink" title="方案二、onWindowFocusChanged()"></a>方案二、onWindowFocusChanged()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Keep in mind that onResume is not the best indicator that your activity</span></span><br><span class="line"><span class="comment">     * is visible to the user; a system window such as the keyguard may be in</span></span><br><span class="line"><span class="comment">     * front.  Use &#123;<span class="doctag">@link</span> #onWindowFocusChanged&#125; to know for certain that your</span></span><br><span class="line"><span class="comment">     * activity is visible to the user (for example, to resume a game).</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">-&gt; Activity 构造函数</span><br><span class="line">-&gt; Activity.setTheme()</span><br><span class="line">-&gt; Activity.onCreate()</span><br><span class="line">-&gt; Activity.onStart</span><br><span class="line">-&gt; Activity.onResume</span><br><span class="line">-&gt; Activity.onAttachedToWindow</span><br><span class="line">-&gt; Activity.onWindowFocusChanged</span><br></pre></td></tr></table></figure><p>onResume()的注释发现用户可见状态  onWindowFocusChanged</p><p>android.app.Activity#onWindowFocusChanged 在什么时候调用的呢？？？</p><blockquote><p>  android.view.Window.Callback#onWindowFocusChanged</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">android.app.ActivityThread#handleResumeActivity()</span><br><span class="line">--- wm.updateViewLayout(decor, l);  <span class="comment">//DecorView  , wm (ViewManager) a.getWindowManager();</span></span><br><span class="line">    --- wm (WindowManagerImpl)  实际上 android.view.WindowManagerGlobal#updateViewLayout</span><br><span class="line">        --- android.view.ViewRootImpl#setLayoutParams</span><br><span class="line">                --- scheduleTraversals</span><br><span class="line">                    --- doTraversal（） -&gt; performTraversals()</span><br><span class="line">                            ---  performDraw（）， performMeasure（） ， performLayout（）</span><br><span class="line">          ---</span><br><span class="line">performTraversals()中有这两句话  host就是mDecorView</span><br><span class="line">host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);  <span class="comment">//将mAttachInfo  和mView 绑定</span></span><br><span class="line">mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">android.view.ViewRootImpl.W   </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus, <span class="keyword">boolean</span> inTouchMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewRootImpl viewAncestor = mViewAncestor.get();</span><br><span class="line">    <span class="keyword">if</span> (viewAncestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">       viewAncestor.windowFocusChanged(hasFocus, inTouchMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">android.view.ViewRootImpl#windowFocusChanged</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus, <span class="keyword">boolean</span> inTouchMode)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = MSG_WINDOW_FOCUS_CHANGED;</span><br><span class="line">        msg.arg1 = hasFocus ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        msg.arg2 = inTouchMode ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">android.view.ViewRootImpl.ViewRootHandler</span><br><span class="line"><span class="comment">//android.view.ViewRootImpl#windowFocusChanged() // mHandler.sendMessage(msg); MSG_WINDOW_FOCUS_CHANGED</span></span><br><span class="line"> <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123; <span class="comment">//mView就是mDecorView</span></span><br><span class="line">   mAttachInfo.mKeyDispatchState.reset();</span><br><span class="line">    mView.dispatchWindowFocusChanged(hasWindowFocus);</span><br><span class="line">    mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三、IdleHandler"><a href="#方案三、IdleHandler" class="headerlink" title="方案三、IdleHandler"></a>方案三、IdleHandler</h3><p><img src="http://ow9n8vqns.bkt.clouddn.com/QQ20180409-102332.png" alt="Handler_looper"></p><blockquote><p>空闲线程MessageQueue 回调<br>向消息队列中添加一个新的MessageQueue.IdleHandler。当调用IdleHandler.queueIdle()返回false时，此MessageQueue.IdleHandler会自动的从消息队列中移除。或者调用removeIdleHandler(MessageQueue.IdleHandler)也可以从消息队列中移除MessageQueue.IdleHandler</p></blockquote><p>activity 所有的生命周期方法都是通过 Handler 处理的，</p><p>结果测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity 构造函数</span><br><span class="line">-&gt; Activity.setTheme()</span><br><span class="line">-&gt; Activity.onCreate()</span><br><span class="line">-&gt; Activity.onStart</span><br><span class="line">-&gt; Activity.onResume</span><br><span class="line">-&gt; Activity.onAttachedToWindow</span><br><span class="line">-&gt; Activity.onWindowFocusChanged</span><br><span class="line">-&gt; IdleHandler 回调</span><br></pre></td></tr></table></figure></p><p>问题 ：IdleHandler回调的时机会受到 Handler.sendxxxMessage 受影响</p><blockquote><p>如果再onCreate方法中 Handler.sendxxxMessage 会影响回调时间</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;顾名思义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人理解，进入Activity开始一直到首屏页面被渲染出来（用户可见状态）这个时间差不多就是Activity的加载时间！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;方案一、onCreate-onResume-的时间
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Arch 架构组件之 ViewModel</title>
    <link href="http://blog.zoudongq123.cn/2018/03/15/Arch-%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E4%B9%8B-ViewModel/"/>
    <id>http://blog.zoudongq123.cn/2018/03/15/Arch-架构组件之-ViewModel/</id>
    <published>2018-03-15T03:08:28.000Z</published>
    <updated>2019-03-16T07:58:47.498Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="arch" scheme="http://blog.zoudongq123.cn/tags/arch/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin基础语法</title>
    <link href="http://blog.zoudongq123.cn/2018/01/03/Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://blog.zoudongq123.cn/2018/01/03/Kotlin基础语法/</id>
    <published>2018-01-03T03:35:39.000Z</published>
    <updated>2019-03-16T07:58:47.502Z</updated>
    
    <content type="html"><![CDATA[<p>1.定义包名（简单和Java 基本一样）<br>2.定义函数</p><blockquote><p>fun 开头表示函数，函数的返回值和形参（java的名称）类型 都是名字后面 ：TYPE (类型都是名称后面加：) 语句结尾分号可以忽略不写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">sum</span><span class="params">(a: Int , b: Int)</span> : Int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  print(<span class="string">"sum of 3 and 5 is "</span>)</span><br><span class="line">  println(sum(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">sum</span><span class="params">(a: Int, b: Int)</span> </span>= a + b     <span class="comment">// 该函数只有一个表达式函数体以及一个自推导型的返回值：</span></span><br></pre></td></tr></table></figure></p></blockquote><p>当函数的不需要返回值时（返回无意义的值时）可以忽略不写  （：Unit）</p><p>更多详细讲解</p><p>3.定义局部变量<br>声明常量（val）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  val a: Int = <span class="number">1</span>  <span class="comment">// 立即初始化</span></span><br><span class="line">  val b = <span class="number">2</span>   <span class="comment">// 推导出Int型</span></span><br><span class="line">  val c: Int  <span class="comment">// 当没有初始化值时必须声明类型</span></span><br><span class="line">  c = <span class="number">3</span>       <span class="comment">// 赋值</span></span><br><span class="line">  println(<span class="string">"a = $a, b = $b, c = $c"</span>)   <span class="comment">//使用了字符串模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>声明变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  var x = <span class="number">5</span> <span class="comment">// 推导出Int类型</span></span><br><span class="line">  x += <span class="number">1</span></span><br><span class="line">  println(<span class="string">"x = $x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.注释 （java 一样）<br>5.字符串模板</p><blockquote><p>可以使用变量名，表达式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">  var a = 1</span><br><span class="line">  // 使用变量名作为模板:</span><br><span class="line">  val s1 = &quot;a is $a&quot;</span><br><span class="line"></span><br><span class="line">  a = 2</span><br><span class="line">  // 使用表达式作为模板:</span><br><span class="line">  val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</span><br><span class="line">  println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>6.条件表达式</p><blockquote><p>if  else   when(取代了switch)<br>if else 这就不多说了， 简单</p></blockquote><p>when 比 switch功能多，  可以使用 常量 和使用表达式 ，in, !in (检查值是否值在一个集合), is !is(判断值是否是某个类型) ,可以用来代替 if-else if<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when (x) &#123;</span><br><span class="line">  <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">  <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">  <span class="keyword">else</span> -&gt; &#123; <span class="comment">//Note the block</span></span><br><span class="line">print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for 循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item in collection)</span><br><span class="line">print(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item: Int in ints)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类似java中的for(int i:array) 但是kotlin更强大    </span></span><br><span class="line"><span class="comment">//java中的切点无法获取 index</span></span><br><span class="line"><span class="comment">//Kotlin可以获取 "indices"</span></span><br><span class="line"><span class="keyword">for</span> (i in array.indices)</span><br><span class="line">print(array[i])</span><br></pre></td></tr></table></figure></p><p>while,do while break,continue  和 java 一样</p><p>7.使用可空变量以及空值检查</p><p>下面的函数是当 str 中不包含整数时返回空:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">parseInt</span><span class="params">(str : String)</span>: Int?</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个返回可空值的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">parseInt</span><span class="params">(str: String)</span>: Int? </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toIntOrNull()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">printProduct</span><span class="params">(arg1: String, arg2: String)</span> </span>&#123;</span><br><span class="line">  val x = parseInt(arg1)</span><br><span class="line">  val y = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接使用 x*y 会产生错误因为它们中有可能会有空值</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; y != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// x 和 y 将会在空值检测后自动转换为非空值</span></span><br><span class="line">    println(x * y)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">"either '$arg1' or '$arg2' is not a number"</span>)</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  printProduct(<span class="string">"6"</span>, <span class="string">"7"</span>)</span><br><span class="line">  printProduct(<span class="string">"a"</span>, <span class="string">"7"</span>)</span><br><span class="line">  printProduct(<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">parseInt</span><span class="params">(str: String)</span>: Int? </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toIntOrNull()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">printProduct</span><span class="params">(arg1: String, arg2: String)</span> </span>&#123;</span><br><span class="line">  val x = parseInt(arg1)</span><br><span class="line">  val y = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">    println(<span class="string">"Wrong number format in arg1: '$&#123;arg1&#125;'"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="keyword">null</span>) &#123;</span><br><span class="line">    println(<span class="string">"Wrong number format in arg2: '$&#123;arg2&#125;'"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// x 和 y 将会在空值检测后自动转换为非空值</span></span><br><span class="line">  println(x * y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下都是空值检查 即 没有 ？ 当为空时不执行该代码片段</p><p>8.for 循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  val items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">  <span class="keyword">for</span> (item in items) &#123;</span><br><span class="line">    println(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  val items = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>)</span><br><span class="line">  <span class="keyword">for</span> (index in items.indices) &#123;   <span class="comment">//indices 是角标</span></span><br><span class="line">    println(<span class="string">"item at $index is $&#123;items[index]&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9.ranges</p><blockquote><p>检查 in 操作符检查数值是否在某个范围内：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  val x = <span class="number">10</span></span><br><span class="line">  val y = <span class="number">9</span></span><br><span class="line">  <span class="keyword">if</span> (x in <span class="number">1</span>..y+<span class="number">1</span>) &#123;</span><br><span class="line">      println(<span class="string">"fits in range"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>检查数值是否在范围外<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  val list = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (-<span class="number">1</span> !in <span class="number">0</span>..list.lastIndex) &#123;</span><br><span class="line">    println(<span class="string">"-1 is out of range"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list.size !in list.indices) &#123;</span><br><span class="line">    println(<span class="string">"list size is out of valid list indices range too"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在范围内迭代<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (x in <span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者使用步进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (x in <span class="number">1</span>..<span class="number">10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (x in <span class="number">9</span> downTo <span class="number">0</span> step <span class="number">3</span>) &#123;</span><br><span class="line">    print(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.定义包名（简单和Java 基本一样）&lt;br&gt;2.定义函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fun 开头表示函数，函数的返回值和形参（java的名称）类型 都是名字后面 ：TYPE (类型都是名称后面加：) 语句结尾分号可以忽略不写&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="Kotlin" scheme="http://blog.zoudongq123.cn/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之建造者模式</title>
    <link href="http://blog.zoudongq123.cn/2017/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zoudongq123.cn/2017/10/12/设计模式之建造者模式/</id>
    <published>2017-10-12T09:40:00.000Z</published>
    <updated>2019-03-16T07:58:47.505Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="设计模式" scheme="http://blog.zoudongq123.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <link href="http://blog.zoudongq123.cn/2017/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zoudongq123.cn/2017/10/12/设计模式之抽象工厂模式/</id>
    <published>2017-10-12T09:20:00.000Z</published>
    <updated>2019-03-16T07:58:47.505Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式总共有23种，分三类：<strong>创建型，结构型，行为型</strong>。</p><p>创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式</p><h3 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h3><blockquote><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p></blockquote><a id="more"></a><p>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类</p><p>抽象工厂设计模式解决了什么问题呢？？</p><blockquote><p>每个工厂只能创建一类产品，即工厂方法模式的缺点</p></blockquote><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="工厂的UML类图"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li>创建抽象工厂类，定义具体工厂的公共接口；</li><li>创建抽象产品族类 ，定义抽象产品的公共接口；</li><li>创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；</li><li>创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；</li><li>创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</li><li>客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例</li></ol><p> 继续沿用简单工厂例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品A抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品B抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAA</span> <span class="keyword">extends</span> <span class="title">ProductA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这A-A类产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAB</span> <span class="keyword">extends</span> <span class="title">ProductA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这A-B类产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductBA</span> <span class="keyword">extends</span> <span class="title">ProductB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这B-A类产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductBB</span> <span class="keyword">extends</span> <span class="title">ProductB</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这B-B类产品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryA</span> <span class="keyword">extends</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductAA();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductAB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryB</span> <span class="keyword">extends</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductBA();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductBB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        Factory mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        mFactoryA.createA().show();</span><br><span class="line">        mFactoryA.createB().show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        Factory mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        mFactoryB.createA().show();</span><br><span class="line">        mFactoryB.createB().show();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>降低耦合</p><blockquote><p>抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；</p></blockquote></li><li><p>更符合开-闭原则</p><blockquote><p>新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 ,简单工厂模式需要修改工厂类的判断逻辑</p></blockquote></li><li>符合单一职责原则<blockquote><p>每个具体工厂类只负责创建对应的产品, 简单工厂中的工厂类存在复杂的switch逻辑判断</p></blockquote></li><li>不使用静态工厂方法，可以形成基于继承的等级结构。<blockquote><p>简单工厂模式的工厂类使用静态工厂方法</p></blockquote></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>抽象工厂模式很难支持新种类产品的变化。<br>这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。</p><blockquote><p>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式总共有23种，分三类：&lt;strong&gt;创建型，结构型，行为型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式&lt;/p&gt;
&lt;h3 id=&quot;抽象工厂设计模式&quot;&gt;&lt;a href=&quot;#抽象工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂设计模式&quot;&gt;&lt;/a&gt;抽象工厂设计模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="设计模式" scheme="http://blog.zoudongq123.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://blog.zoudongq123.cn/2017/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zoudongq123.cn/2017/10/12/设计模式之工厂模式/</id>
    <published>2017-10-12T09:10:12.000Z</published>
    <updated>2019-03-16T07:58:47.505Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式总共有23种，分三类：<strong>创建型，结构型，行为型</strong>。</p><p>创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式</p><h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><blockquote><p>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p></blockquote><a id="more"></a><p>将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。</p><p>工厂设计模式解决了什么问题呢？？</p><blockquote><p>解决简单工厂缺点：工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则。因为工厂方法模式把具体产品的d额创建推迟到工厂类的子类（具体工厂）中，此时工程类不再负责所有产品的创建，而z还是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不需要修改工厂类的逻辑而是添加新的工厂子类（具体工厂），这符合开放-关闭原则，解决了简单工厂的缺点</p></blockquote><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="工厂的UML类图"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li>创建抽象工厂类，定义具体工厂的公共接口；</li><li>创建抽象产品类 ，定义具体产品的公共接口；</li><li>创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；</li><li>创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；</li><li>外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</li></ol><p> 继续沿用简单工厂例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryA</span> <span class="keyword">extends</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryB</span> <span class="keyword">extends</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryC</span> <span class="keyword">extends</span>  <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ProductC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        Factory mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        mFactoryA.create().show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        Factory mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        mFactoryB.create().show();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>更符合开-闭原则<br>   新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可<br>   简单工厂模式需要修改工厂类的判断逻辑</li><li>符合单一职责原则<br>   每个具体工厂类只负责创建对应的产品<br>   简单工厂中的工厂类存在复杂的switch逻辑判断</li><li>不使用静态工厂方法，可以形成基于继承的等级结构。<br>   简单工厂模式的工厂类使用静态工厂方法</li></ol><p>总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li><li>一个具体工厂只能创建一种具体产品</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式总共有23种，分三类：&lt;strong&gt;创建型，结构型，行为型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式&lt;/p&gt;
&lt;h3 id=&quot;工厂设计模式&quot;&gt;&lt;a href=&quot;#工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;工厂设计模式&quot;&gt;&lt;/a&gt;工厂设计模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="设计模式" scheme="http://blog.zoudongq123.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之简单工厂模式</title>
    <link href="http://blog.zoudongq123.cn/2017/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zoudongq123.cn/2017/10/12/设计模式之简单工厂模式/</id>
    <published>2017-10-12T09:06:12.000Z</published>
    <updated>2019-03-16T07:58:47.505Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式总共有23种，分三类：<strong>创建型，结构型，行为型</strong>。</p><p>创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式</p><h3 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h3><blockquote><p>简单工厂设计模式也称静态工程设计模式，因为一般来说简单工厂的工厂类定义了一个静态方法</p></blockquote><a id="more"></a><p>简单工厂设计模式解决了什么问题呢？？</p><blockquote><p>将<code>类实例化的操作</code>和 <code>使用对象的操作</code>分开了，让使用者不用知道具体参数就可以实例化出所需要的“产品“类，从而避免了客户端代码中过多的实例化操作，实现了解耦。</p></blockquote><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="简单工厂的UML类图"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li>创建抽象产品类</li><li>创建具体产品类</li><li>创建工厂类 ： 通过创建静态方法根据传入的参数不一样返回不同的产品类的实例。</li></ol><p><img src="http://ourl4v8fh.bkt.clouddn.com/timg.jpeg" alt="举个例子"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductC</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String productname)</span></span>&#123;</span><br><span class="line"><span class="comment">//工厂类里用switch语句控制生产哪种商品；</span></span><br><span class="line"><span class="comment">//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。</span></span><br><span class="line">        <span class="keyword">switch</span> (productname)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductC();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂产品生产流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Factory mFactory = <span class="keyword">new</span> Factory();</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用工厂类的静态方法 &amp; 传入不同参数从而创建产品实例</span></span><br><span class="line">            mFactory.createProduct(<span class="string">"A"</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.createProduct(<span class="string">"B"</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//客户要产品C</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.createProduct(<span class="string">"C"</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//客户要产品D</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mFactory.createProduct(<span class="string">"D"</span>).Show();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有这一类产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；</li><li>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li><li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li><li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式总共有23种，分三类：&lt;strong&gt;创建型，结构型，行为型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式&lt;/p&gt;
&lt;h3 id=&quot;简单工厂设计模式&quot;&gt;&lt;a href=&quot;#简单工厂设计模式&quot; class=&quot;headerlink&quot; title=&quot;简单工厂设计模式&quot;&gt;&lt;/a&gt;简单工厂设计模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;简单工厂设计模式也称静态工程设计模式，因为一般来说简单工厂的工厂类定义了一个静态方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="设计模式" scheme="http://blog.zoudongq123.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://blog.zoudongq123.cn/2017/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zoudongq123.cn/2017/10/12/设计模式之单例模式/</id>
    <published>2017-10-12T09:05:51.000Z</published>
    <updated>2019-03-16T07:58:47.504Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式总共有23种，分三类：<strong>创建型，结构型，行为型</strong>。</p><p>创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>顾名思义：只有一个实例对象</p></blockquote><p>写法大概有7种</p><h4 id="第一种（懒汉，线程不安全）："><a href="#第一种（懒汉，线程不安全）：" class="headerlink" title="第一种（懒汉，线程不安全）："></a>第一种（懒汉，线程不安全）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法延迟加载很明显，但是致命的是在多线程不能正常工作。</p><h4 id="第二种（懒汉，线程安全）："><a href="#第二种（懒汉，线程安全）：" class="headerlink" title="第二种（懒汉，线程安全）："></a>第二种（懒汉，线程安全）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，效率很低，99%情况下不需要同步。</p><h4 id="第三种（饿汉）："><a href="#第三种（饿汉）：" class="headerlink" title="第三种（饿汉）："></a>第三种（饿汉）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到延迟加载的效果。</p><h4 id="第四种（饿汉，变种）："><a href="#第四种（饿汉，变种）：" class="headerlink" title="第四种（饿汉，变种）："></a>第四种（饿汉，变种）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance</p><h4 id="第五种（静态内部类）："><a href="#第五种（静态内部类）：" class="headerlink" title="第五种（静态内部类）："></a>第五种（静态内部类）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到延迟加载效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。</p><h4 id="第六种（枚举）："><a href="#第六种（枚举）：" class="headerlink" title="第六种（枚举）："></a>第六种（枚举）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p><h4 id="第七种（双重校验锁）："><a href="#第七种（双重校验锁）：" class="headerlink" title="第七种（双重校验锁）："></a>第七种（双重校验锁）：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是第二种方式的升级版，俗称双重检查锁定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有两个问题需要注意：</p><ol><li>如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。</li><li>如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。</li></ol><p>对于第一个问题修复的办法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span>      </span></span><br><span class="line"><span class="function">                                         <span class="keyword">throws</span> ClassNotFoundException </span>&#123;     </span><br><span class="line">      ClassLoader classLoader = Thread.currentThread().getContextClassLoader();     </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)     </span><br><span class="line">         classLoader = Singleton.class.getClassLoader();     </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> (classLoader.loadClass(classname));     </span><br><span class="line">   &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于第二个问题修复的办法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();     </span><br><span class="line">      </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        </span><br><span class="line">   &#125;     </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;     </span><br><span class="line">      &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现延迟加载效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。</p><p><strong>不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式总共有23种，分三类：&lt;strong&gt;创建型，结构型，行为型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式&lt;/p&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
    
      <category term="设计模式" scheme="http://blog.zoudongq123.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识体系之GC算法</title>
    <link href="http://blog.zoudongq123.cn/2017/10/11/JVM%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8BGC%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zoudongq123.cn/2017/10/11/JVM知识体系之GC算法/</id>
    <published>2017-10-11T10:13:48.000Z</published>
    <updated>2019-03-16T07:58:47.501Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。<br>JVM 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 <strong>Java堆和方法区</strong>中，在程序运行期间，这部分内存的分配和使用都是动态的.</p><h4 id="如何判断对象是否存活"><a href="#如何判断对象是否存活" class="headerlink" title="如何判断对象是否存活"></a>如何判断对象是否存活</h4><p>判断对象是否存活一般有两种方式：</p><ol><li><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象<strong>相互循环引用</strong>的问题。</li><li><strong>可达性分析</strong>（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。<br> 在Java语言中，GC Roots包括：<pre><code>虚拟机栈中引用的对象。方法区中类静态属性实体引用的对象。方法区中常量引用的对象。本地方法栈中JNI引用的对象。</code></pre></li></ol><p><img src="http://ourl4v8fh.bkt.clouddn.com/gcroots.png" alt="gc roots"></p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h5><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>它的主要缺点有两个：一个是<strong>效率问题</strong>，<strong>标记和清除过程的效率都不高</strong>；另外一个是<strong>空间问题</strong>，标记清除之后会产生<strong>大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-清除示意图"></p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。<br>优点: （1）标记阶段和复制阶段可以同时进行。<br>     （2）每次只对一块内存进行回收，运行高效。<br>     （3）只需移动栈顶指针，按顺序分配内存即可，实现简单。<br>     （4）内存回收时不用考虑内存碎片的出现（得活动对象所占的内存空间之间没有空闲间隔）。<br>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="复制示意图"></p><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png" alt="复制示意图"></p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h4 id="垃圾收集器-（JDK-7-虚拟机提供的几种垃圾收集器）"><a href="#垃圾收集器-（JDK-7-虚拟机提供的几种垃圾收集器）" class="headerlink" title="垃圾收集器 （JDK 7)虚拟机提供的几种垃圾收集器）"></a>垃圾收集器 （JDK 7)虚拟机提供的几种垃圾收集器）</h4><blockquote><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p></blockquote><h5 id="Serial收集器-（Copying算法）"><a href="#Serial收集器-（Copying算法）" class="headerlink" title="Serial收集器 （Copying算法）"></a>Serial收集器 （Copying算法）</h5><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）<br>参数控制：-XX:+UseSerialGC  串行收集器</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="Serial收集器"></p><h5 id="ParNew收集器-（Copying算法）"><a href="#ParNew收集器-（Copying算法）" class="headerlink" title="ParNew收集器 （Copying算法）"></a>ParNew收集器 （Copying算法）</h5><p>ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩<br>参数控制：-XX:+UseParNewGC  ParNew收集器<br>-XX:ParallelGCThreads 限制线程数量</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="ParNew收集器"></p><h5 id="Parallel收集器-（Copying算法）"><a href="#Parallel收集器-（Copying算法）" class="headerlink" title="Parallel收集器 （Copying算法）"></a>Parallel收集器 （Copying算法）</h5><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p><p>参数控制：-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行</p><h5 id="Parallel-Old-收集器（标记—整理算法）"><a href="#Parallel-Old-收集器（标记—整理算法）" class="headerlink" title="Parallel Old 收集器（标记—整理算法）"></a>Parallel Old 收集器（标记—整理算法）</h5><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p><p>参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行</p><h5 id="CMS收集器（标记—整理算法）"><a href="#CMS收集器（标记—整理算法）" class="headerlink" title="CMS收集器（标记—整理算法）"></a>CMS收集器（标记—整理算法）</h5><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： </p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p><p>优点:并发收集、低停顿<br>缺点：产生大量空间碎片、并发阶段会降低吞吐量<br>参数控制：-XX:+UseConcMarkSweepGC  使用CMS收集器<br>        -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br>        -XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理<br>        -XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS收集器"></p><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p><ol><li>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</li><li>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ol><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="g1"></p><p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p>收集步骤：</p><p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p><p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p><p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8-2.png" alt="g2"></p><p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8-3.png" alt="g3"></p><p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p><img src="http://ourl4v8fh.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8-4.png" alt="g4"></p><p>[参考]：<br>（<a href="http://www.jianshu.com/p/5261a62e4d29）" target="_blank" rel="noopener">http://www.jianshu.com/p/5261a62e4d29）</a><br>（<a href="http://www.cnblogs.com/ityouknow/p/5614961.html）" target="_blank" rel="noopener">http://www.cnblogs.com/ityouknow/p/5614961.html）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经
      
    
    </summary>
    
      <category term="android" scheme="http://blog.zoudongq123.cn/categories/android/"/>
    
      <category term="java" scheme="http://blog.zoudongq123.cn/categories/android/java/"/>
    
    
      <category term="JVM" scheme="http://blog.zoudongq123.cn/tags/JVM/"/>
    
  </entry>
  
</feed>
