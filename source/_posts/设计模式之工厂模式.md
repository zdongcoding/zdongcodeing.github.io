---
title: 设计模式之工厂模式
copyright: true
categories: android
date: 2017-10-12 17:10:12
tags: 设计模式
---

设计模式总共有23种，分三类：**创建型，结构型，行为型**。

创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式


### 工厂设计模式
> 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

<!-- more -->
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。


工厂设计模式解决了什么问题呢？？
>解决简单工厂缺点：工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则。因为工厂方法模式把具体产品的d额创建推迟到工厂类的子类（具体工厂）中，此时工程类不再负责所有产品的创建，而z还是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不需要修改工厂类的逻辑而是添加新的工厂子类（具体工厂），这符合开放-关闭原则，解决了简单工厂的缺点


![工厂的UML类图](http://ourl4v8fh.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png)

#### 使用步骤
1. 创建抽象工厂类，定义具体工厂的公共接口；
2. 创建抽象产品类 ，定义具体产品的公共接口；
3. 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
4. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
5. 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例


 继续沿用简单工厂例子

```java
//抽象工厂类
abstract class Factory{
    public abstract Product create();
}
//具体工厂类A
class  FactoryA extends  Factory{

    @Override
    public Product create() {
        return new ProductA();
    }
}
//具体工厂类B
class  FactoryB extends  Factory{

    @Override
    public void create() {
       return new ProductB();
    }
}
//具体工厂类C
class  FactoryC extends  Factory{

    @Override
    public void create() {
       return new ProductC();
    }
}
```
工厂模式的使用方法：
```java
//工厂产品生产流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        Factory mFactoryA = new FactoryA();
        mFactoryA.create().show();

        //客户要产品B
        Factory mFactoryB = new FactoryB();
        mFactoryB.create().show();
        ...
    }
}
```
#### 优点
1. 更符合开-闭原则
      新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
      简单工厂模式需要修改工厂类的判断逻辑
2. 符合单一职责原则
      每个具体工厂类只负责创建对应的产品
      简单工厂中的工厂类存在复杂的switch逻辑判断
3. 不使用静态工厂方法，可以形成基于继承的等级结构。
      简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

#### 缺点
1. 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
3. 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
4. 一个具体工厂只能创建一种具体产品
