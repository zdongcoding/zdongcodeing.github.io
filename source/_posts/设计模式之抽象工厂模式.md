---
title: 设计模式之抽象工厂模式
copyright: true
categories: android
date: 2017-10-12 17:20:00
tags: 设计模式
---

设计模式总共有23种，分三类：**创建型，结构型，行为型**。

创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式

### 抽象工厂设计模式
> 抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。

<!-- more -->
抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类


抽象工厂设计模式解决了什么问题呢？？
>每个工厂只能创建一类产品，即工厂方法模式的缺点


![工厂的UML类图](http://ourl4v8fh.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)

#### 使用步骤
1. 创建抽象工厂类，定义具体工厂的公共接口；
2. 创建抽象产品族类 ，定义抽象产品的公共接口；
3. 创建抽象产品类 （继承抽象产品族类），定义具体产品的公共接口；
4. 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
5. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
6. 客户端通过实例化具体的工厂类，并调用其创建不同目标产品的方法创建不同具体产品类的实例


 继续沿用简单工厂例子

```java
//抽象工厂类
abstract class Factory{
    public abstract Product createA();
    public abstract Product createB();
}
//产品A抽象类
abstract class ProductA extends Product{
    @Override
    public abstract void show();
}
//产品B抽象类
abstract class ProductB extends Product{
    @Override
    public abstract void show();
}
//具体产品类
class ProductAA extends ProductA{
    @Override
    public abstract void show(){
        System.out.println("这A-A类产品");
    }
}
class ProductAB extends ProductA{
    @Override
    public abstract void show(){
        System.out.println("这A-B类产品");
    }
}
class ProductBA extends ProductB{
    @Override
    public abstract void show(){
        System.out.println("这B-A类产品");
    }
}
class ProductBB extends ProductB{
    @Override
    public abstract void show(){
        System.out.println("这B-B类产品");
    }
}
//具体工厂类A
class  FactoryA extends  Factory{

    @Override
    public Product createA() {
        return new ProductAA();
    }
      @Override
    public Product createB() {
        return new ProductAB();
    }
}
//具体工厂类B
class  FactoryB extends  Factory{
  @Override
    public Product createA() {
        return new ProductBA();
    }
      @Override
    public Product createB() {
        return new ProductBB();
    }
}
```
工厂模式的使用方法：
```java
//工厂产品生产流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        Factory mFactoryA = new FactoryA();
        mFactoryA.createA().show();
        mFactoryA.createB().show();

        //客户要产品B
        Factory mFactoryB = new FactoryB();
        mFactoryB.createA().show();
        mFactoryB.createB().show();
        ...
    }
}
```
#### 优点
1. 降低耦合
>抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展；

2. 更符合开-闭原则
 >新增一种产品类时，只需要增加相应的具体产品类和相应的工厂子类即可 ,简单工厂模式需要修改工厂类的判断逻辑
3. 符合单一职责原则
>每个具体工厂类只负责创建对应的产品, 简单工厂中的工厂类存在复杂的switch逻辑判断
4. 不使用静态工厂方法，可以形成基于继承的等级结构。
>简单工厂模式的工厂类使用静态工厂方法


#### 缺点
抽象工厂模式很难支持新种类产品的变化。
这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。
>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。