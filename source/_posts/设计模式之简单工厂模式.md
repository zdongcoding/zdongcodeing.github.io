---
title: 设计模式之简单工厂模式
copyright: true
categories: android
date: 2017-10-12 17:06:12
tags: 设计模式
---

设计模式总共有23种，分三类：**创建型，结构型，行为型**。

创建型(5种): 单例，简单工厂，工厂，抽象工厂，建造者，原始 这五种设计模式。这次我们来说说工厂设计模式


### 简单工厂设计模式
> 简单工厂设计模式也称静态工程设计模式，因为一般来说简单工厂的工厂类定义了一个静态方法

<!-- more -->

简单工厂设计模式解决了什么问题呢？？
>将`类实例化的操作`和 `使用对象的操作`分开了，让使用者不用知道具体参数就可以实例化出所需要的“产品“类，从而避免了客户端代码中过多的实例化操作，实现了解耦。

![简单工厂的UML类图](http://ourl4v8fh.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png)

#### 使用步骤
1. 创建抽象产品类
2. 创建具体产品类
3. 创建工厂类 ： 通过创建静态方法根据传入的参数不一样返回不同的产品类的实例。

![举个例子](http://ourl4v8fh.bkt.clouddn.com/timg.jpeg)

```java
//抽象产品类
abstract class Product{
    public abstract void show();
}
//具体产品类A
class  ProductA extends  Product{

    @Override
    public void show() {
        System.out.println("生产出了产品A");
    }
}
//具体产品类B
class  ProductB extends  Product{

    @Override
    public void show() {
        System.out.println("生产出了产品C");
    }
}
//具体产品类C
class  ProductC extends  Product{

    @Override
    public void show() {
        System.out.println("生产出了产品C");
    }
}
//简单工厂类
class  Factory {
    public static Product createProduct(String productname){
//工厂类里用switch语句控制生产哪种商品；
//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。
        switch (productname){
            case "A":
                return new ProductA();

            case "B":
                return new ProductB();

            case "C":
                return new ProductC();

            default:
                return null;

        }
    }
}
```
简单工厂模式的使用方法：
```java
//工厂产品生产流程
public class SimpleFactoryPattern {
    public static void main(String[] args){
        Factory mFactory = new Factory();
        //客户要产品A
        try {
                //调用工厂类的静态方法 & 传入不同参数从而创建产品实例
            mFactory.createProduct("A").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
        //客户要产品B
        try {
            mFactory.createProduct("B").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
        //客户要产品C
        try {
            mFactory.createProduct("C").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
        //客户要产品D
        try {
            mFactory.createProduct("D").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
    }
}
```
#### 优点
1. 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
2. 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。
#### 缺点
1. 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
2. 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
3. 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。
